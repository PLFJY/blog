[{"title":"KNN 的浅薄学习笔记","url":"/KNN-shallow-learning-note/","content":"今天了解了一下机器学习，看到了KNN这种算法，因为没搞懂，所以打算把学习过程写成博文辅助自己理解\n代码参考 kaggle 上的 Handwritten digits Classification(Using KNN ) 和 Movie Ratings and Recommendation using KNN\n这是啥？KNN，全称 “ k-nearest neighbor classification”，是一种机器学习算法，它是一种基于分类的有监督学习方式，核心思想是“相似样本有相似输出”，从一大堆数据集中进行训练，所以会有训练集，和测试集，一般是三七开或者二八开，训练集会把样本和标记全部给到模型，然后库比如 scikit-learn 或者 pytorch 会对数据进行处理，或者你可以手动实现，然后你给它个新的值就能做预测。其中KNN中的 K 代表的是 k 值，表示这个新的东西临近的样本的个数，k 值会直接影响模型判断的准确率，如果 k 值过大可能就欠拟合，也就是没找到规律；k 值过小就是过拟合，简单说就是新数据的不认识，只认识训练数据，接下来是实现和使用过程\n怎么实现？使用现有库以 Scikit-learn 举例，首先拿到数据，对数据进行预处理，学习的话一般数据会从数据集的库里拿，比如 scikit-learn自己的数据集 ，具体数据集对应的使用方法都在API文档里面，我们拿这个Handwritten digits Classification(Using KNN )的代码来做例子：\n首先是数据导入和预处理\nfrom sklearn import datasets # 从库里获取数据集from sklearn.cross_validation import train_test_split  # 用于数据集拆分（注意：新版本sklearn已移至model_selection）mnist = datasets.load_digits() # 加载MNIST手写数字数据集，这个就是原始数据# 拆分数据，测试集和训练集 2.5 7.5开(trainData, testData, trainLabels, testLabels) = train_test_split(    np.array(mnist.data),  # 图像数据（反正是处理过的）    mnist.target,  # 标签（0-9的数字）    test_size=0.25,  # 测试集占比    random_state=42  # 保证复现结果的固定随机数种子)# 额外从训练集拿出来的验证集，和训练集一九开(trainData, valData, trainLabels, valLabels) = train_test_split(    trainData,  # 上一步得到的训练集数据    trainLabels,  # 上一步得到的训练集标签    test_size=0.1,  # 验证集占比（相对于当前训练集）    random_state=84  # 保证复现结果的固定随机数种子)# 所以总结下来：# trainData 是训练数据; trainLabels 是训练数据的答案# testData 是测试数据; testLabels 是测试数据的答案# valData 是验证数据; valLabels 是验证数据的答案# 然后下面的代码是拿训练集和验证集来做 k 值尝试\n\n然后是使用 scikit-learn 库来做机器学习，第一步是弄个 k 值预设表 kVals，之后的 k 值就会从这里一个一个试，试到满意为止\nkVals = range(1, 30, 2) # 1 ~ 30 之间的所有奇数，换成C#也就是 Enumerable.Range(1, 30).Where(x =&gt; x%2 != 0);accuracies = [] # 存储准确率的列表\n\n这里是最重要的地方，接下来就是一个一个试 k 值了\n# 导入几个新的工具from sklearn.neighbors import KNeighborsClassifier  # K近邻分类器，说白了就是你的模型for k in kVals: # 这里源代码不好，我做了一些改编    model = KNeighborsClassifier(n_neighbors=k)  # 初始化模型，设置模型基本参数 (k值)    model.fit(trainData, trainLabels)  # 拟合数据（其实就是训练模型，scikit-learn 帮你实现了）\t        score = model.score(valData, valLabels) # 拿验证集去测一下训练好的模型，这一步也是 scikit-learn 实现好的，直接出准确率    print(f&#x27;k值是&#123;k&#125;, 准确率是&#123;score&#125;&#x27;) # 打印一下调试，不用管    accuracies.append(score)  # 把得到的准确率存下来（话说为啥不用字典）\n\n试出来所有 k 值对应的准确率后就该正式训练模型了\n# 导入一下新的工具import numpy as npi = np.argmax(accuracies)  # 利用 numpy 的 argmax 方法获取到最高的准确率的 indexprint(f&#x27;k=&#123;kVals[i]&#125;的时候准确率最高，准确率是&#123;accuracies[i]&#125;&#x27;) # 打印一下调试，不用管# 用最新的 k 值训练模型model = KNeighborsClassifier(n_neighbors=kVals[i])model.fit(trainData, trainLabels)score = model.score(testData, testLabels) # 拿测试集去测一下训练好的模型，看看准确率print(f&#x27;最终模型的准确率是&#123;score&#125;&#x27;) # 最后看看准确率\n\n差不多了，后面都是无关紧要的验证，最重要的是前面的实现，那么接下来就是手动实现的案例了\n手动实现Movie Ratings and Recommendation using KNN 的代码使用的是手动实现的方式，它实现了一个电影评价系统，开始它先导入了两张表\nimport pandas as pd # 用来导入表的库movies = pd.read_csv(&#x27;../input/tmdb-movie-metadata/tmdb_5000_movies.csv&#x27;) # 导入电影信息的表credits = pd.read_csv(&#x27;../input/tmdb-movie-metadata/tmdb_5000_credits.csv&#x27;) # 导入工作人员信息的表\n\n接着的部分是利用输出辨别数据结构，不是KNN讨论的重点，所以我们略过这一部分\n接下来合并了两张表方便后续处理\nmovies = movies.merge(credits,left_on=&#x27;id&#x27;,right_on=&#x27;movie_id&#x27;,how=&#x27;left&#x27;)movies = movies[[&#x27;id&#x27;,&#x27;original_title&#x27;,&#x27;genres&#x27;,&#x27;cast&#x27;,&#x27;vote_average&#x27;,&#x27;director&#x27;,&#x27;keywords&#x27;]]\n\n下面是它核心的算法部分，用于从多个维度计算两个电影之间的距离\nfrom scipy import spatialdef Similarity(movieId1, movieId2):    # 分别提取两个电影的特征    a = movies.iloc[movieId1]    b = movies.iloc[movieId2]        # 计算各特征向量的距离，使用的余弦    genresA = a[&#x27;genres_bin&#x27;]    genresB = b[&#x27;genres_bin&#x27;]    genreDistance = spatial.distance.cosine(genresA, genresB)  # 类型距离        scoreA = a[&#x27;cast_bin&#x27;]    scoreB = b[&#x27;cast_bin&#x27;]    scoreDistance = spatial.distance.cosine(scoreA, scoreB)  # 评分距离        directA = a[&#x27;director_bin&#x27;]    directB = b[&#x27;director_bin&#x27;]    directDistance = spatial.distance.cosine(directA, directB)  # 导演距离        wordsA = a[&#x27;words_bin&#x27;]    wordsB = b[&#x27;words_bin&#x27;]    wordsDistance = spatial.distance.cosine(wordsA, wordsB)  # 关键词距离(原代码此处笔误，已修正)        # 总距离为各特征距离之和    return genreDistance + directDistance + scoreDistance + wordsDistance\n\n所以我们可以用下面的方式来调用这个函数\nSimilarity(3,160) #checking similarity between any 2 random movies\n\n下面，它定义了一个分数预测器 predic_score(name) 函数，这里面是模型训练和获取预测值的相关逻辑，详细拆解如下:\n\n这里是最重要的地方，在这个函数里面，它先定义了一个“获取邻居”的方法\ndef getNeighbors(baseMovie, K):    distances = []    # 遍历所有电影，计算与目标电影的距离    for index, movie in movies.iterrows():         if movie[&#x27;new_id&#x27;] != baseMovie[&#x27;new_id&#x27;].values[0]:  # 排除自身            dist = Similarity(baseMovie[&#x27;new_id&#x27;].values[0], movie[&#x27;new_id&#x27;])            distances.append((movie[&#x27;new_id&#x27;], dist))  # 以(电影ID，距离)的tuple来存储        # 按距离升序排序（距离越小越相似）    distances.sort(key=operator.itemgetter(1))        # 取前K个最近邻    neighbors = []    for x in range(K):        neighbors.append(distances[x])    return neighbors\n\n下面是获取预测值的步骤，这里我已经把 getNeighbors(baseMovie, K) 抽象到上面了，方便理解\ndef predict_score(name):    # 找到符合目标电影关键词的列表    new_movie = movies[movies[&#x27;original_title&#x27;].str.contains(name)].iloc[0].to_frame().T    print(&#x27;Selected Movie: &#x27;, new_movie.original_title.values[0])        K = 10  # 取10个邻居，拟定 k 值为 10，实际并没有经过过测试    neighbors = getNeighbors(new_movie, K)  # 获取最近的10个邻居        # 输出匹配到的10个结果    print(&#x27;Recommended Movies: &#x27;)    avgRating = 0    for neighbor in neighbors:        avgRating += movies.iloc[neighbor[0]][&#x27;vote_average&#x27;]  # 累加近邻评分        print(f&quot;&#123;movies.iloc[neighbor[0]][&#x27;original_title&#x27;]&#125; | Genres: &#123;str(movies.iloc[neighbor[0]][&#x27;genres&#x27;]).strip(&#x27;[]&#x27;).replace(&#x27; &#x27;,&#x27;&#x27;)&#125; | Rating: &#123;movies.iloc[neighbor[0]][&#x27;vote_average&#x27;]&#125;&quot;) # 打印匹配到的电影的详情        # 预测评分（近邻平均评分）这步已经是多余了，主要是根据KNN的思想，假设相似的电影具有相似的属性，那么作用是，如果电影未上映，则可以预测出一个可能的评分    avgRating /= K    print(f&#x27;\\nThe predicted rating for &#123;new_movie[&quot;original_title&quot;].values[0]&#125; is: &#123;avgRating&#125;&#x27;)    print(f&#x27;The actual rating for &#123;new_movie[&quot;original_title&quot;].values[0]&#125; is &#123;new_movie[&quot;vote_average&quot;].values[0]&#125;&#x27;)\n\n这就是关于这个的全部解析了\n下面是个人有关第二个手动实现的代码的一些想法\n\n\n结合面向对象编程那么我们现在看到，这个代码的遍历方式和比较方式是很笨拙的，可扩展性不高，要是再有多一点东西，基本上就能感觉到修改极其吃力，并且我们理解也需要花很高的成本\n下面这个音乐分类的例子采用了面向对象的思想\nimport randomfrom typing import List, Dict, Tuple, Optionalfrom py_linq import EnumerableGENRES = [&quot;classical&quot;, &quot;rock&quot;, &quot;jazz&quot;, &quot;pop&quot;, &quot;hiphop&quot;, &quot;electronic&quot;]ARTISTS = &#123;    &quot;classical&quot;: [&quot;Bach&quot;, &quot;Mozart&quot;, &quot;Beethoven&quot;, &quot;Chopin&quot;, &quot;Tchaikovsky&quot;],    &quot;rock&quot;: [&quot;The Beatles&quot;, &quot;The Rolling Stones&quot;, &quot;Queen&quot;, &quot;AC/DC&quot;, &quot;Nirvana&quot;],    &quot;jazz&quot;: [&quot;Miles Davis&quot;, &quot;Louis Armstrong&quot;, &quot;Duke Ellington&quot;, &quot;Charlie Parker&quot;],    &quot;pop&quot;: [&quot;Taylor Swift&quot;, &quot;Ed Sheeran&quot;, &quot;Rihanna&quot;, &quot;Bruno Mars&quot;],    &quot;hiphop&quot;: [&quot;Jay-Z&quot;, &quot;Kendrick Lamar&quot;, &quot;Eminem&quot;, &quot;Drake&quot;],    &quot;electronic&quot;: [&quot;Deadmau5&quot;, &quot;Daft Punk&quot;, &quot;Avicii&quot;, &quot;Skrillex&quot;]&#125;KEYS = [&quot;C Major&quot;, &quot;D Major&quot;, &quot;E Major&quot;, &quot;F Major&quot;, &quot;G Major&quot;, &quot;A Major&quot;, &quot;B Major&quot;,        &quot;C Minor&quot;, &quot;D Minor&quot;, &quot;E Minor&quot;, &quot;F Minor&quot;, &quot;G Minor&quot;, &quot;A Minor&quot;, &quot;B Minor&quot;]LANGUAGES = [&quot;English&quot;, &quot;中文&quot;, &quot;한국어&quot;, &quot;日本語&quot;, &quot;Español&quot;, &quot;Русский язык&quot;, &quot;اللغة العربية&quot;, &quot;Français&quot;]class Music:    def __init__(self, title, genre, bpm, artist, key, lang, complexity, is_labeled = False):        self.title = title        self.genre = genre        self.bpm = bpm        self.artist = artist        self.key = key        self.lang = lang        self.complexity = complexity        self.is_labeled = is_labeled    def __repr__(self) -&gt; str:        return f&quot;&#123;self.title&#125;: &#123;self.genre&#125; (BPM: &#123;self.bpm:.1f&#125;, Artist: &#123;self.artist&#125;)&quot;        def artist_diff(self, other):        if(self.artist == other.artist):            return 0                    self_artist_key = (Enumerable(ARTISTS.items())                           .where(lambda x : self.artist in x[1])                           .select(lambda x : x[0])                           .first())                return 1 if other.artist in ARTISTS[self_artist_key] else 2            def genres_diff(self, other):        return 0 if self.genre == other.genre else 2        def keys_diff(self, other):        return 0 if self.key == other.key else 2            def langs_diff(self, other):        return 0 if self.lang == other.lang else 2        def bpm_diff(self, other):        return abs(self.bpm - other.bpm)        def distance(self, other):        return self.artist_diff(other) + self.bpm_diff(other) + self.genres_diff(other) + self.keys_diff(other) + self.langs_diff(other)class Music_Collection:    def __init__(self, l):        self.l = l    def find_neighbors(self, music, num):        distances = []        for item in self.l:            if(item == music):                continue            distances.append((music.distance(item), item))        distances.sort(key=lambda x : x[0])        return [item for (dist, item) in distances[:num]]# Generated By AIclass MusicDataGenerator:    &quot;&quot;&quot;静态音乐数据生成器类，提供静态方法生成符合特征范围的随机数据集&quot;&quot;&quot;    # 静态方法无需实例化即可调用    @staticmethod    def set_seed(seed: int) -&gt; None:        &quot;&quot;&quot;设置随机种子，用于复现结果&quot;&quot;&quot;        random.seed(seed)        @staticmethod    def generate_music(genre: str, title: str, is_labeled: bool = True) -&gt; Music:        GENRE_FEATURE_RANGES = &#123;        &quot;classical&quot;: &#123;&quot;bpm_min&quot;: 60, &quot;bpm_max&quot;: 120, &quot;complexity&quot;: (7, 10)&#125;,        &quot;rock&quot;: &#123;&quot;bpm_min&quot;: 100, &quot;bpm_max&quot;: 160, &quot;complexity&quot;: (5, 8)&#125;,        &quot;jazz&quot;: &#123;&quot;bpm_min&quot;: 80, &quot;bpm_max&quot;: 140, &quot;complexity&quot;: (6, 10)&#125;,        &quot;pop&quot;: &#123;&quot;bpm_min&quot;: 100, &quot;bpm_max&quot;: 130, &quot;complexity&quot;: (3, 6)&#125;,        &quot;hiphop&quot;: &#123;&quot;bpm_min&quot;: 80, &quot;bpm_max&quot;: 110, &quot;complexity&quot;: (4, 7)&#125;,        &quot;electronic&quot;: &#123;&quot;bpm_min&quot;: 120, &quot;bpm_max&quot;: 180, &quot;complexity&quot;: (5, 9)&#125;        &#125;        &quot;&quot;&quot;生成一首特定类型的音乐&quot;&quot;&quot;        if genre not in GENRE_FEATURE_RANGES:            raise ValueError(f&quot;Unknown genre: &#123;genre&#125;&quot;)                    features = GENRE_FEATURE_RANGES[genre]                # 在类型特征范围内生成BPM        bpm = random.uniform(features[&quot;bpm_min&quot;], features[&quot;bpm_max&quot;])                # 从该类型的艺术家列表中随机选择        artist = random.choice(ARTISTS[genre])                # 随机选择音调和语言        key = random.choice(KEYS)        lang = random.choice(LANGUAGES)                # 生成复杂度        complexity = random.uniform(features[&quot;complexity&quot;][0], features[&quot;complexity&quot;][1])                return Music(            title=title,            genre=genre,            bpm=bpm,            artist=artist,            key=key,            lang=lang,            complexity=complexity,            is_labeled=is_labeled        )        @staticmethod    def generate_by_genre(genre: str, count: int = 1, start_index: int = 0) -&gt; List[Music]:        &quot;&quot;&quot;生成指定数量的特定类型音乐&quot;&quot;&quot;        music_list = []        for i in range(count):            title = f&quot;&#123;genre&#125;_track_&#123;start_index + i + 1&#125;&quot;            music = MusicDataGenerator.generate_music(genre, title)            music_list.append(music)        return music_list        @staticmethod    def generate_balanced_dataset(total_count: int = 1) -&gt; List[Music]:        &quot;&quot;&quot;生成均衡的数据集，每个类型数量大致相同&quot;&quot;&quot;        genre_count = len(GENRES)        base_count = total_count // genre_count        remainder = total_count % genre_count                dataset = []        current_index = 0                for i, genre in enumerate(GENRES):            # 分配数量，处理余数            count = base_count + (1 if i &lt; remainder else 0)            genre_tracks = MusicDataGenerator.generate_by_genre(genre, count, current_index)            dataset.extend(genre_tracks)            current_index += count                # 打乱数据集顺序        random.shuffle(dataset)        return dataset        @staticmethod    def generate_unknown_music(count: int = 1) -&gt; List[Music]:        &quot;&quot;&quot;生成指定数量的未分类音乐&quot;&quot;&quot;        unknowns = []        for i in range(count):            # 随机选择一个类型作为基础，但不设置标签            genre = random.choice(GENRES)            title = f&quot;unknown_track_&#123;i+1&#125;&quot;            music = MusicDataGenerator.generate_music(genre, title, is_labeled=False)            music.genre = &quot;unknown&quot;  # 清除标签            unknowns.append(music)        return unknownsif(__name__ == &quot;__main__&quot;):    # random seed insure reproducible    MusicDataGenerator.set_seed(45)    training_data = MusicDataGenerator.generate_balanced_dataset(1000)    collection = Music_Collection(training_data) # training data generate    # unknown music genrate    # unknown_tracks = MusicDataGenerator.generate_by_genre(&quot;pop&quot;)    # unknown_tracks = MusicDataGenerator.generate_by_genre(&quot;classical&quot;)    # unknown_tracks = MusicDataGenerator.generate_by_genre(&quot;rock&quot;)    unknown_tracks = MusicDataGenerator.generate_by_genre(&quot;electronic&quot;)    print(f&quot;Unknown tracks detail is:&#123;unknown_tracks[0]&#125;&quot;)    print(&quot;\\nFound Tracks:&quot;)    found_tracks = collection.find_neighbors(unknown_tracks[0], 10)    for track in found_tracks:        print(track)\n\n","tags":["python","machine learning"]},{"title":"Linux 折腾相关记录","url":"/linux-related/","content":"折腾了这么久linux，好多小问题，每解决一个我都扔进来一个，虽然可能只有我自己看的懂，就当随笔记录吧，我时不时可能会拿一些出来单独写点文章啥的\n修复 Linux 中的一个噪音问题（Intel 必备）：https://cyril3.github.io/2020/05/17/fix-linux-popup-noise\nsudo vim /etc/modprobe.d/disable_snd_hda_intel_power_save.confoptions snd_hda_intel power_save=0\n\nKDE导入splash Screen的地址:/home/&lt;user name&gt;/.local/share/plasma/look-and-feel/\nKDE Wallpaper插件：https://github.com/slynobody/SteamOS-wallpaper-engine-kde-plugin\nDisable KDE wallet (有风险，别用，可能会让VS Code启动的时候卡住):vim ~/.config/kwalletrc\n\n[Wallet]Enabled=false\n\n建议直接：\nparu -S kwallet-pam\n让它自启动\nNumberlock:早启动paru -S mkinitcpio-numlocksudo vim /etc/mkinitcpio.conf\n\nnumlock\nsudo mkinitcpio -P\n\nSDDMsudo vim /etc/sddm.conf\n\n[General]Numlock=on\n\n腾讯会议 Nvidia看别人黑屏：设置环境变量__EGL_VENDOR_LIBRARY_FILENAMES=/usr/share/glvnd/egl_vendor.d/50_mesa.json\n在Exec&#x3D;后面添加env __EGL_VENDOR_LIBRARY_FILENAMES=/usr/share/glvnd/egl_vendor.d/50_mesa.json\n音量控制问题paru -S plasma-pa pavucontrol\n\nVLC编码问题装个插件\nparu -S vlc-plugin-ffmpeg\n\n用 KDE 配置这么久感觉其他要装的软件(组件、插件)paru -S gwenview okular elisa spectacle breeze-gtk remmina kwin-effect-rounded-corners-git\n\nKDE小组件plasmusic-toolbar\nGRUB UEFI的图标把 menuentry 开头的这一行在后面的大括号前面加上 --class efi\nv4l2loopback需要装header，不然没得dkms用\nparu -S linux-headers\n启动\nsudo modprobe v4l2loopback\n列出设备\nsudo v4l2-ctl --list-devices\n重启\nsudo modprobe -r v4l2loopback &amp; sudo modprobe v4l2loopback\n剩下查wiki\nhttps://wiki.archlinux.org/title/V4l2loopback\nRime用雾凇拼音 https://github.com/iDvel/rime-ice\nfastfetch显示图片可以用kitty的 –kitty-direct 传图片\nzsh直接用 ohmyzsh\n一些装了的插件：\ngit zsh-syntax-highlighting zsh-autosuggestions copypath copybuffer sudo colorize\n\n好用的性能监视器paru -S htop\n\nArch pacman 自动选出最快的镜像源https://qiedd.com/1203.html\nparu -S reflectorsudo reflector --verbose --country &#x27;China&#x27; -l 200 -p https --sort rate --save /etc/pacman.d/mirrorlist","tags":["linux","kde"]},{"title":"虚拟语气","url":"/subjunctive-mood/","content":"主表\n\n\n类型\n时间意义\n口诀\n结构\n例句\n\n\n\n真实条件句\n表事实或可能\n主将从现\nIf + 一般现在，主句 will + 原形\nIf it rains, we will stay home.\n\n\n现在虚拟\n与现在事实相反\n主过将从一过\nIf + 过去式，主句 would + 原形\nIf I were you, I would leave.\n\n\n过去虚拟\n与过去事实相反\n主过将完从过完\nIf + had + 过去分词，主句 would have + 过去分词\nIf I had known, I would have told you.\n\n\n将来虚拟\n表极不可能将来\n主将从 should &#x2F; were to\nIf + should&#x2F;were to + 动词原形，主句 would + 原形\nIf he should come, I would tell him.\n\n\nwish 句型\n现在愿望\nwish 从过\nwish + 过去式\nI wish I were taller.\n\n\nwish 句型\n过去后悔\nwish 从过完\nwish + had + 过去分词\nI wish I had gone there.\n\n\nIf 速查：\n\n\n主句\n时间意义\n从句\n\n\n\n将来\n事实或可能\n一般现在\n\n\n过去将来\n与现在事实相反\n一般过去\n\n\n过去将来完成\n与过去事实相反\n过去完成\n\n\n将来\n不可能的将来\nshould &#x2F; were to\n\n\nWish 速查:\n\n\n时间意义\n从句\n\n\n\n现在愿望\n一般过去\n\n\n过去后悔\n过去完成\n\n\n","tags":["english","grammar"]},{"title":"AP CSA 00 - 关于AP Computer Science A","url":"/ap-csa/00-about-ap-csa/","content":"\n  \n    \n      警告\n\n    \n    \n      因为目前仍在施工中，部分内容仍未完成。标题中所有标记了“WIP（Working in progress）”的都是未完成的部分\n\n    \n  \n\n以下是一些考试的概况，我尽量每个问题两句话内说完\nQ: 考什么？A: Java基础\nQ: Java是什么？A: 一种面向对象 (Object oriented programming 简称 OOP) 编程语言，常用于网站后端和安卓软件开发，其它的用处你要用也能用，知名的沙盒游戏Minecraft就是它写的\n至于面向对象是什么……我后面会讲\nQ: 考数据结构之类的复杂的东西吗？A: 不，会基础就好，最难也就递归、归并排序和二分查找了，这几个也考的不深\nQ: 难学吗？A: 个人认为理解了本质就很好上手，下面是考试大纲，我接下来的文章会按照我自己对于编程的理解的新编排序来讲，理解完再回去看大纲然后刷题，5分手到擒来\n考试大纲\n","categories":["AP CSA"],"tags":["AP","Java","AP CSA"]},{"title":"AP CSA 01 - 一些基础","url":"/ap-csa/01-basic-concept/","content":"写在前头: 学习编程不要妄想自己什么都能一行行搞懂，所有无法理解的东西且本文我说了你不用知道的东西完全不用在乎，因为一时半会影响不了你的学习，学到后面有了一定的知识积累或者渐渐理解编程的本质之后，通过查阅文档，就能自然而然的理解那些当年不知道的内容。\n当然，我会尽力把所有的点“为什么出现？”、“解决什么问题？”、“与先前的有什么关系？”介绍清楚，希望你不会因为到一半跟丢了就跟不上了。\n先介绍一些编程基础概念 (考试不考，但我要说)：1. 编译 (Compile)首先，我们都知道，电脑只认识0和1，所以你写的代码它当然是看不懂的。正是因为如此，需要编译。\n编译就是指把你写的代码转换为机器码的过程，但是我需要强调的是现在编程语言普遍分为3种，运行效率由高到低如下：\n\n编译型，指你写的代码会被完全编译成汇编语言，至于汇编是啥你不用管，你只需要知道这玩意跟000111的二进制是差不多一个级别的底层玩意就行，运行速度最快，缺点是很繁琐，写的比较慢，而且需要手动管理内存，没管好就爆了，例如：C&#x2F;C++、Rust、Go。\n托管型（Java所在的类型），指你写的代码会被翻译成一种中间语言，交给运行器托管运行，运行器看这种中间语言效率相对较高，虽然运行效率略低于编译型，但是会比解释型要强不少，它的优势在于，可以自动释放内存，不用考虑跑着跑着内存爆了的问题，例如：Java、C#。\n解释型（又称脚本型），指你写的代码会被运行器一行一行看着执行，虽然有些语言会有优化，也不需要手动管理内存，但是总的来看，还是效率最低，例如：Python、JavaScript。\n\n「实际情况比这里说的要复杂得多，这里只是一个简化模型，帮助理解不同语言的大致类别。至于管理内存的问题由于JAVA是托管型，我们不需要考虑这个问题，不理解可以直接不理它」\n2. 运行 (Run)指你的代码被实际跑在设备上的过程\n3. 环境 (Environment)代码不是能凭空编译和运行的，代码是给人看的，只有机器码才是机器看的，尤其是后面两种类型的编程语言也不是能直接独立运行的，需要一个运行器或者编译器，电脑里装上这个的过程叫做配环境\n属于Java的特殊概念Java因为是托管型语言，所以是跑在一个叫做 JVM (Java Virtual Machine) 的虚拟机上的，这里又有同学要问了，”虚拟机是什么”，了当的说就是一个不真实的环境，类似给你的代码套了个壳，你的代码在壳里面跑，至于壳是怎么跑在电脑上的你不用管，上面说了环境是装在你电脑上的，出来的东西是直接和电脑硬件交互，那么不直接跑在你电脑硬件上的都叫虚拟机，Java为了能一套代码能在各种平台上运行，比如Windows电脑、Mac电脑、Linux电脑、Android手机，这个叫做跨平台，所以给每个设备都准备了一种虚拟机，你的代码不用变，就能直接依靠这个虚拟机跑在各个不同的设备上，结合前面的东西图示如下\n\n（注：图片内容有点问题，iOS由于系统的特殊性不允许托管型语言，所以跑不了）\n图标资源来自：icons8\n接下来是 JAVA 的 两种工具类型：\n\nJRE (Java Runtime Environment) ，只有 JVM，没有上面的编译器，只能用来跑，没法编译，这个是给用户装的\nJDK (JAVA Development Kit)，既有 JVM 还有编译器，已经包含了 JRE 了，写代码装这个\n\n配环境接下来是装 JDK 配环境，直接看别人写好的文章就好了，我不造轮子了\n\nWindows\nMac\nLinux\n\n为了方便我们看和写代码，我们需要一个专门的工具来写，你总不可能拿记事本写不是？\nAP官方内推荐使用 IntelliJ IDEA，但是这玩意是给大项目用的，我们只是学习个语言，犯不着这么高级的东西，于是我们使用 Visual Studio Code\n下载这个 VS Code -&gt; https://code.visualstudio.com/Download\n然后调中文这一步我就不教了，都要考 AP 了还调什么中文，有需要的可以自行 Google 搜索\n接下来为了能在 VS Code 丝滑的写 Java 代码用于练习安装 Java 插件\n我们可以在这里看到一个这个Extensions图标，点开它\n\n然后在搜索框内搜索 Java，然后根据图示安装 Extension Pack for Java\n\n写代码这一步我们先开始试着跑出来第一个代码，让我们来尝试一下，首先先在 VS Code 里面打开一个文件夹\n\n点开左上角 Files -&gt; Open Folder 选一个你喜欢的地方确定\nJava程序是以类为单位运行的，所以我们需要创建一个新的类\n然后在左侧的导航栏打开最上面的 Explore，右键 Explore 的空白处 New Java File -&gt; Class...，顶上会弹出来让你写文件名，把文件名敲进去回车，你应该能看到这个\npublic class &lt;你刚刚敲进去的文件名&gt; &#123;    &#125;\n\n这个就是一个Java的类，我们先不管它是做啥的\n在这个地方里面直接粘贴下面的代码，后面的章节我会解释这个什么意思\npublic static void main(String[] args) &#123;        System.out.println(&quot;Hello World&quot;);    &#125;\n\n然后右上角点一下那个小三角▶️，不出意外你应该能看到下面大致长这样：\n\n你看到那个 Hello World 就是成功了\n注释 (Comments)有些时候我们需要给别人或者未来的自己留下一些备注，告诉他们有一部分是干什么用的，既然是备注就应该是给人读的不是给机器读的，所以机器看到注释会直接跳过不看，你可以在注释里面塞任何的东西，不会影响程序\n注释有两种方式：\n\n// 本行后面的所有内容都会被转成注释，编译器都不看\n/* */ 被 /* 和 */ 包裹住的内容都会变成注释，可以跨行\n\n比如：\n//这一行内后面的都会变成注释/* 这里可以放东西这里的内容都是注释这里也可以写东西*/\n\n一定一定要注意的编程中的所有符号全部给我用英文的半角符号，不知道这是啥的就给我切成英文再写代码，或者直接把中文输入法关了，比如逗号，区分一下：， 这个是中文的，, 这个是英文的\n中文的是全角符号，会比英文的宽好多，而且会圆润一点，你敲中文的编译器不认识，敲错了没看出来别说你编程是我教的\n以下是容易敲错符号的列表，代码跑不起来的时候请自查符号问题：\n\n\n\n符号名称\n中文符号\n英文符号\n\n\n\n逗号 comma\n，\n,\n\n\n分号 semicolon\n；\n;\n\n\n句点 period\n。\n.\n\n\n小括号 curve\n（ ）\n( )\n\n\n中括号 square bracket\n【 】\n[ ]\n\n\n大括号 bracket\n「 」\n{ }\n\n\n感叹号 bang or shriek\n！\n!\n\n\n双引号 double quotes\n“ ”\n&quot; &quot;\n\n\n单引号 single quote\n‘ ’\n&#39; &#39;\n\n\n输出 (有叫打印 Print)计算机是用来计算的，它算完了总得告诉我们算了啥，所以就有了输出，刚才你在底下那块区域看到的 Hello World 就是输出的内容，那个地方叫做控制台，我们的输出就会出现在那里\n这里是 AP 选择题的一个考点，有关于 Java 程序的输出\n像刚刚我们在上方看到的如下代码\npublic static void main(String[] args) &#123;        System.out.println(&quot;Hello World&quot;);    &#125;\n\n里面的\nSystem.out.println(&quot;Hello World&quot;);\n\n就是 Java 中的输出语句，它会将双引号里面的内容打印 (Print) 到你的控制台上，就像上面的图片里那样\n\n这里我们就要引申出 AP 计算机科学一个我都不知道考了有什么意义的考点了，输出的两种语句\nJava 的输出有两个语句，一个是你上面看到的 System.out.println(&quot;Hello World&quot;);\n还有一个是下面这里的\nSystem.out.print(&quot;Hello World&quot;);\n\n它们的区别就是一个 ln，那么这一个 ln 究竟区别有多大呢？\n我们用下面的例子来理解一下：\n//我们先执行一下System.out.print(&quot;Hello AP &quot;);//然后紧接着执行一下System.out.println(&quot;Computer Science A&quot;);//然后我们再接一条System.out.println(&quot;This is an example&quot;);\n\n执行之后的输出结果是这样的：\nHello AP Computer Science AThis is an example\n\n我相信细节的小伙伴已经发现区别了，没错不带 ln 的输出后不换行，带 ln 的输出后会进行换行，那么接着它打印的内容就会出现在下一行\n那么这里我就可以放一个我对练习题的改编题了，题目如下：\nSystem.out.println(&quot;My Name is PLFJY&quot;);System.out.print(&quot;I Love &quot;);System.out.println(&quot;AP Computer Science A&quot;);System.out.print(&quot;Glad to &quot;);System.out.print(&quot;See you&quot;);\n\nWhat is printed as a result of executing the code segment above?\nA.My Name is PLFJY I LoveAP Computer Science AGlad to See you\nB.My Name is PLFJYI Love AP Computer Science AGlad to See you\nC.My Name is PLFJYI Love AP Computer Science AGlad toSee you\nD.My Name is PLFJYI LoveAP Computer Science AGlad toSee you\n正确答案是 B，解析：\n第1行 System.out.println(&quot;My Name is PLFJY&quot;); 带ln，所以下一行换行输出，所以此时输出内容如下\nMy Name is PLFJY\n\n第2行 System.out.print(&quot;I Love &quot;); 不带 ln，所以下一行不换行输出，当前控制台上的内容如下\nMy Name is PLFJYI Love \n\n第3行 System.out.println(&quot;AP Computer Science A&quot;); 带 ln，所以下一行换行输出，当前控制台上的内容如下\nMy Name is PLFJYI Love AP Computer Science A\n\n第4行 System.out.print(&quot;Glad to &quot;); 不带 ln，所以下一行换行输出，当前控制台上的内容如下\nMy Name is PLFJYI Love AP Computer Science AGlad to\n\n第5行 System.out.println(&quot;See you&quot;); 带 ln，所以下一行换行输出，但是已经是最后一句了所以没啥影响，最后控制台上的内容如下\nMy Name is PLFJYI Love AP Computer Science AGlad to See you\n\n本章节到此结束\n","categories":["AP CSA"],"tags":["AP","Java","AP CSA"]},{"title":"AP CSA 02 - 数据类型","url":"/ap-csa/02-data-types/","content":"接下来终于到正式内容了，这里还是按照顺序的，本章节对应考纲Unit 1的内容\n前言类型这个东西在我看来是编程中非常重要的一个部分，因为它决定了一切内容的基础，从C语言开始就已经有了类型的概念，虽然在脚本型语言中类型的概念被不断弱化，但是在学习编程的过程中我认为类型还是一个不可绕过的内容\n首先，为什么会有类型？计算机不认识我们习以为常的整数、文本、小数、是非、列表，我们需要告诉计算机，我们要存进计算机的数据是什么东西，所以诞生了类型的概念，那么在计算机中，只有电脑知道了是什么类型，计算机才能用对应的方式处理对应的数据\n考试中的数据类型AP考试关注以下这几种数据类型：\n\nint –&gt; 整数\nfloat –&gt; 单精度小数（又称浮点数）（考试不考）\ndouble –&gt; 双精度小数\nboolean –&gt; 中文是啥不重要，知道它只有 true 和 false 两个状态就行\nchar –&gt; 字符（考试不考，但是是下面字符串的组成部分）\nString –&gt; 字符串（重点，后面会单独开一章讲）\nArray –&gt; 数组\nArrayList –&gt; 列表\n自定义类型 –&gt; 这个会在面向对象的部分单独讲，非常关键\n\nint (Integer) 整数int 是整数类型，和数学上的定义是一样的，我就不抄 Google 了，这里有几个特性：\n\n默认值是 0\nint 拥有自增自减运算，这个在下一章变量会讲，其实就是 +1 和 -1\ndouble 转换为 int 会舍弃后面的小数位数，只保留整数，举个例子，1.5 转成 int 类型则是 1，不存在四舍五入，四舍五入是一个特殊算法，后面会讲，主要用到的就是这个性质\n上限和下限具体值不用记，代码里用 Integer.MAX_VALUE 和Integer.MIN_VALUE 就好了，AP用不着，但是要提一嘴\n\ndouble 小数double是小数类型，又称浮点数类型，和数学上定义一样，不过没有循环小数了，多的部分会存不进去，直接截断，特性如下：\n\n编程中的凡是浮点类型精度都有限，不要妄想通过这个来算账，尤其是精密的东西，有需要可自行 Google “高精度”\n也有自增和自减运算，但一般没人对小数做这个，所以当个乐子知道就行\n默认值是 0.0d，d 表示双精度浮点，啥意思也不用管，提一嘴\n前面说过，和 int 之间的类型转换问题，这里是反过来的，int 转 double 完整保留，直接转换即可，比如1 从 int 转换成 double 会变成 1.0 \n上限和下限分别是 Double.MIN_VALUE Double.MIN_VALUE，AP也用不着，当了解了\n\nboolean 中文是啥不重要我们需要在一些时候去判断一件事的真假，比如雅思阅读当中，有一段话我们要判断 True、False 、Not Given（这个编程中没有，别找了），虽然我们可以依靠 int 类型的 0、1来判断，但是有一个单独的类型能够代表这个当然是最好的\nboolean 别的语言里有的又称 bool 类型，中文是啥不重要 (我就算说了它叫布尔你也不知道是干啥的)，它只有 2 个性质：\n\n这种类型只有两种情况，true 或者 false\n前面加上 ! 会取反，比如 !true == false, (1 != 3) == true\n这里由于字体的原因我重新打一下上面那个被搞成不等于号的符号，在编程中写作：‘!&#x3D;’，之后的博文中看到 !=，自动看成 ‘!&#x3D;’\n\n\n这个是补充知识：编程中 = 指的是赋值操作，不是常规的等于号，下一章讲，要比较相等请使用 ==\n又由于字体原因不好分辨出来，我再打一遍，赋值是 ‘&#x3D;’，比较相等是 ‘&#x3D;&#x3D;’，以后的博文中注意长度的不同\n\n\n\nString  字符串顾名思义，字符组成的串，在代码里我们通常用双引号扩起来，第一章你应该记得见过像这样的 &quot;Hello World&quot; ，这玩意就叫字符串，这里不详细介绍，后面单独开一章。&#39;A&#39; 这种叫字符char，AP考试不考字符\nArray和 ArrayList这俩货不是最基本的基础数据类型，后面再说，先放着，你一时半会也见不到，其实就是一串同类型的数据连着一起\n本章节到此结束\n","categories":["AP CSA"],"tags":["AP","Java","AP CSA"]},{"title":"AP CSA 03 - 变量","url":"/ap-csa/03-var/","content":"这里应该还是在考纲Unit 1的范围之内，今天讲一个编程中很常见的话题：变量和常量\n变量 (Variables)首先是变量，变量 (Variables) 你就想象成一个容器，可以用来存放任何东西，比如：数字、文本、符号、对象(这个后面会讲)\n当你创建了这一个容器之后，Java 会根据数据类型的不同给这个容器在内存上分配一部分的空间\n定义(创建)变量 (Declaring Variables)那么变量究竟该如何被定义（创建）呢？我们在 Java 中是这样操作的：\n//&lt;数据类型&gt;&lt;空格&gt;&lt;变量名&gt;;//比如：int a;//这里就是定义了一个名字为 a 的 int 类型变量\n\n好的那么我们总得个 a 里面放一个东西吧？这个放东西的操作叫做赋值 (assignment)，赋值的操作是这样的：\na = 10;//这里就是给 a 设置了一个数字 10//也可以在变量定义的时候给它赋值，叫做赋初始值，//下面的意思为创建一个值为 3.5 的 double 类型的变量 bdouble b = 3.5;\n\n这个就是赋值语句：assignment statement\n运算数字类型的变量可以进行运算：\na = 10 + 1;//意思就是把 10 + 1 的值赋值给变量 a//那么此时 a 里面的值就是 10 + 1 = 11\n\n当然，运算的式子里面也可以有变量：\nb = b - 1.5;//意思是把 b - 1.5 的值赋值给变量 b//那么此时变量 b 里面的值就是 3.5 - 1.5 = 2\n\n每次写这种带自身的加减运算都好麻烦，都要写两遍这个变量的名字，能不能简化一点？还真可以：\nb -= 1.5;//这里完全等价于上面的 b = b - 1.5;//那么举一反三一下加法就是b += 1.5;\n\n自增自减运算那么这里就可以引入一种很新颖的运算符号，上一章提到过，叫做自增自减运算\nint i = 0;i++;//意思是把 i 自身 +1，等价于 i = i + 1; 等价于 i += 1;//那么此时 i 的值就是 0 + 1 = 1i--;//意思是把 i 自身 -1，等价于 i = i - 1; 等价于 i -= 1;//那么此时 i 的值就是 1 - 1 = 0\n\n然后这个运算你也可以把符号放前面，单独一条没有任何区别，但是如果和别的东西组合在一起的话这两种写法是有很大的差别的：\n++i;--i;\n这么写也是合法的，但是接下来是个重点🌟🌟🌟，AP的课本里不讲，但是写FRQ里面千万不要写错了\n自增自减符号在后面时，如果我们获取这整条式子的值像这样：\n//在这一行的时候 i 是 0int c = i++;\n那么此时变量的 c 里面是先拿到了 i 自增之前的值，i 再进行自增运算这一条式子过后，c 里面的值是 0，然后 i++，i 的值变成了 1\n理所当然反过来，自增自减符号在前面时，就是先进行自增自减运算，再拿到 i 的值：\n//为了方便理解，我先把 i 改成 3i = 3;int c = --i;\n那么此时变量 i 先进行自减运算，这里 i 先变成了 3 - 1 = 2，然后 c 再拿到 i 的值，现在 c 里面是 2\n取模 (mod) %好的这种自增自减讲完了接下来是取模 (mod) %取模运算就是取余数，比如：\nint d = 3 % 2;//那么 d 里面的值就是 3 ÷ 2 的余数，也就是1\n\n至于这个运算有啥用呢？主要有如下作用：\n\n判断奇偶拿任意数字 %2，然后看有没有余数，有余数就是奇数，没有就是偶数，比如上面的 3 % 2 我们得到余 1 所以 3 就是奇数\n分解位数拿任意数字 %10，那么我们就可以得到最后一位的数字，比如 123 % 10 我们可以得到最后一位 3，可以用前一章讲过的整数类型的特性来进行后续操作，没学会也不要紧\n\nString 变量String 变量的定义是这样的，文本的内容需要用双引号引起来\nString s = &quot;Hello World&quot;;//意思是创建了一个名字叫 s 的文本内容为 &quot;Hello World&quot; 的String变量\n准确说这个应该是 String 类型的对象，但是这里为了方便理解先统一叫做变量\n拓展知识：变量类型自动推导那么这里我们来补充一个AP用不到考试也不能用的知识点，听得懂就记着，听不懂就算了，跳过去就行Java支持自动类型推导，也就是我们可以通过给初始值的方式让Java编译器自动识别这个变量应该是什么类型的，例子：\nvar c = 5;//var 是用于创建自动类型推导变量的关键字//因为值是 5，所以Java自动推导类型为 int//整个的意思就是，创建一个，初始值为 5，自动推导类型为 int 的变量//等价于 int c = 5\n\n  \n    \n      警告\n\n    \n    \n      不要在FRQ（简答题）里面这么写，给我乖乖写清楚变量类型！题目就是考你对于类型的掌握，这里只是作知识补充\n\n    \n  \n\n变量的命名 (Naming Variables)好的接下来是个重点，变量名称不能是编译器预定关键字，这些东西编译器另有他用，不能用于取名包括上一章里面的所有数据类型和boolean的true或false，全部的都列在本章节最后附录的表里面了，你要脑力充足可以去背，我建议是不用背，变量取名的时候稍微用稍微复杂一点的名字就好了：Java 保留关键字 (Java Reserved Keywords)\n变量的命名应该遵循易读原则，需要描述清楚它的用途，且不应过长\n\n吐槽时间：我不知道为啥教算法的都教学生创建变量是 abcd 的，完全没有规律可循，纯纯误人子弟，我前面举例子的变量都没啥意义，所以可以用 abcd 之类的，但是只要你的变量是要存有意义的数据，那么就要有良好的命名\n\n在 Java 中，变量的命名通常采用 小驼峰(lower camel case) 命名方法，即除第一个单词外，每一个单词开头字母大写，例如：userName、helloWorld、myNameIsZero，现在对于一些专有名词的大小写意见不一，我习惯是大写，看你们，比如ID、SQL、UI一类的，但是总得来说一切遵循易读原则\n举个例子：如果我要创建一个类型用于表示一个学生，那么他应该有如下的信息需要存：\n\n姓名\n年龄\n性别\n班级\n学号\n\n那么与之相对的，我取名就应该是这个样子：\n\nname\nage\ngender\nclass\nstudentID\n\n一些惯用的命名习惯有些变量的命名已经形成了习惯，最好按照习惯来写，而不是采用自创的命名\n比如，你需要用一个临时变量存一些内容，那么这个变量的名称按照习惯一般会被取名为 temp 或者 tmp 都是代表暂存的意思\n又比如，你要存一个文档的文件大小，我们一般不会用全称 document，而是会用简称 doc，所以取名就是 docSize\n还有一个最经典的例子，就是参数 argument，一般没人会写完全称，太长了，都是直接用 arg，复数用 args\n总的来说就是有很多简写需要注意，不是说你写全称会错，而是你可能会看不懂别人写的简写\n知识补充：常量 (Constants)本来学编程这个玩意是绕不过去的，但是不知道为什么AP它不讲也不考，所以我在这就作为只是补充来讲了\n什么是常量常量也是也是一个容器，它用来存放代码运行中不会后续出现任何变化的量，比如软件名称、版本号之类的\n常量的声明 (Declaring Constants)常量的声明和变量类似，前面讲过变量的声明是这样的：\n//&lt;数据类型&gt;&lt;空格&gt;&lt;变量名&gt;;//比如：int a;\n\n那么常量的声明就是这样的：\n//final&lt;空格&gt;&lt;数据类型&gt;&lt;空格&gt;&lt;变量名&gt;;//比如：final int a = 20;\n\n常量需要在声明的时候就赋好初始值，至于剩下的，就都一样了，但是区别就是常量里的值无法被修改\na = 10;// 报错，常量无法被修改\n\n但是可以被访问：\nint b = a;// 此时 b 的值就是 20\n\n就是这样\n本章节到此结束\n附录Java 保留关键字 (Java Reserved Keywords)1. 数据类型与值类型 (Data Types &amp; Literals)\n\n\n关键字\n含义\n\n\n\nbyte\n8 位整数类型\n\n\nshort\n16 位整数类型\n\n\nint\n32 位整数类型\n\n\nlong\n64 位整数类型\n\n\nfloat\n32 位浮点数类型\n\n\ndouble\n64 位浮点数类型\n\n\nchar\n单个 Unicode 字符\n\n\nboolean\n布尔类型（true&#x2F;false）\n\n\ntrue\n布尔真值\n\n\nfalse\n布尔假值\n\n\nnull\n空引用字面值\n\n\nvoid\n无返回值类型\n\n\n2. 类与对象 (Classes, Objects &amp; Interfaces)\n\n\n关键字\n含义\n\n\n\nclass\n定义类\n\n\ninterface\n定义接口\n\n\nenum\n定义枚举类型\n\n\nextends\n类继承或接口继承\n\n\nimplements\n类实现接口\n\n\nthis\n当前对象引用\n\n\nsuper\n父类对象引用\n\n\nnew\n创建对象实例\n\n\ninstanceof\n测试对象类型\n\n\npackage\n声明包名\n\n\nimport\n引入类或包\n\n\n3. 访问控制与修饰符 (Access &amp; Modifiers)\n\n\n关键字\n含义\n\n\n\npublic\n公有访问修饰符\n\n\nprotected\n受保护访问修饰符\n\n\nprivate\n私有访问修饰符\n\n\nstatic\n静态成员或方法\n\n\nfinal\n不可修改、最终定义\n\n\nabstract\n抽象类或方法\n\n\nsynchronized\n同步控制（多线程）\n\n\nvolatile\n多线程可见性变量\n\n\ntransient\n序列化时跳过的成员\n\n\nnative\n使用本地（C&#x2F;C++）方法\n\n\nstrictfp\n限定浮点计算精度\n\n\n4. 控制语句 (Control Flow)\n\n\n关键字\n含义\n\n\n\nif\n条件判断\n\n\nelse\n条件分支\n\n\nswitch\n多分支选择\n\n\ncase\nswitch 分支\n\n\ndefault\n默认分支\n\n\nfor\n循环\n\n\nwhile\n循环\n\n\ndo\n循环（先执行后判断）\n\n\nbreak\n跳出循环或 switch\n\n\ncontinue\n跳过当前循环\n\n\nreturn\n返回结果\n\n\nyield\n从 switch 表达式返回值（Java 14+）\n\n\n5. 异常与错误处理 (Exception Handling)\n\n\n关键字\n含义\n\n\n\ntry\n异常捕获块\n\n\ncatch\n捕获异常\n\n\nfinally\n无论异常与否都会执行\n\n\nthrow\n抛出异常\n\n\nthrows\n声明可能抛出的异常\n\n\nassert\n断言条件（调试用）\n\n\n6. 继承与多态 (Inheritance &amp; Polymorphism)\n\n\n关键字\n含义\n\n\n\nsuper\n引用父类\n\n\nthis\n引用当前对象\n\n\ninstanceof\n判断类型关系\n\n\n7. 模块系统 (Modules, since Java 9)\n\n\n关键字\n含义\n\n\n\nmodule\n定义模块\n\n\nrequires\n声明模块依赖\n\n\nexports\n导出包\n\n\nopens\n允许反射访问包\n\n\nuses\n声明使用服务接口\n\n\nprovides\n提供服务实现\n\n\nto\n限定导出目标模块\n\n\nwith\n指定服务实现类\n\n\n\nJava 当前共有 67 个保留关键字 + 3 个字面值 (true, false, null)。\n","categories":["AP CSA"],"tags":["AP","Java","AP CSA"]},{"title":"AP CSA 04 - 顺序，分支，和循环 (WIP)","url":"/ap-csa/04-sequence-branch-loop/","content":"这一章讲的是程序的执行方式，程序的执行分为三种：\n\n顺序\n分支\n循环\n\n接下来我会对于这三种执行方式依次展开说说\n顺序 (Sequence)顺序执行顾名思义就是根据从上到下的顺序依次执行每一行代码，就像是我在第1章提到的输出的样例题目那样，那种就是顺序执行，这个应该很好理解，直接过，重要的是下面两个\n分支 (Branch)分支结构，又称选择结构，它能够根据特定的条件判断程序该往哪里走，举一个很现实的例子\n现在到了晚饭时间，你要选择去食堂还是点外卖，你就要判断一下钱够不够对吧！如果打开微信钱包，钱够，那就点外卖，否则就去食堂刷饭卡\n上面这个例子就是一个很经典的分支结构的例子，那么我们该怎么写分支结构呢？\n在Java中，分支结构采用的是 if，以及 switch，由于switch AP不考，所以我会作为补充知识来讲\n首先是 if，我们就拿上面的例子来写一段伪代码\n打开微信钱包if (还有钱)&#123;    点外卖;&#125;else&#123;    去食堂;&#125;\n\n写成流程图就是这样：\nflowchart TD\n    A[打开微信钱包] --> B{查看还剩多少钱}\n    B -->|还有钱| C[点外卖]\n    B -->|否则| D[去食堂]\n\n就是这么简单，如果点钱够就点外卖，否则就去食堂\nif 语句中，后面的括号是判断条件，里面应该是一个 boolean 值，当为 true 的时候它就会执行 if 里面的内容，不满足就会执行 else里面的内容\nelse 是可选的，你完全可以不写，还是拿刚刚伪代码的例子，你吃完饭就得去上课，但是今天食堂没饭，所以你没钱的话就只能饿着了所以转换成伪代码是这样的：\n打开微信钱包if (还有钱)&#123;    点外卖;&#125;上课;\n\n还有钱的话就点外卖，钱不够的话也不会执行什么特定的代码，不管你吃不吃饭你都要去上课，就是这样\n那么我们来说怎么样才能是一个合格的 boolean 类型的判断条件\n","categories":["AP CSA"],"tags":["AP","Java","AP CSA"]},{"title":"Hexo 支持 Markdown == 高亮扩展语法","url":"/hexo/highlight-text/","content":"借助GPT弄了个js脚本，增加到header就行，它可以自动监听swup的页面切换事件并替换==为&lt;mark&gt;&lt;/mark&gt;，代码如下：\n(function () &#123;  &#x27;use strict&#x27;;  // 要跳过的标签（不在这些标签内进行替换）  const SKIP_TAGS = new Set([&#x27;CODE&#x27;, &#x27;PRE&#x27;, &#x27;SCRIPT&#x27;, &#x27;STYLE&#x27;, &#x27;TEXTAREA&#x27;]);  // 非贪婪匹配 ==...==，允许跨空格和特殊字符  const MARK_RE = /==([\\s\\S]+?)==/g;  // 判断节点是否在我们需要跳过的标签内  function isInsideSkippedTag(node) &#123;    while (node) &#123;      if (node.nodeType === 1 &amp;&amp; SKIP_TAGS.has(node.tagName)) return true;      node = node.parentNode;    &#125;    return false;  &#125;  // 将单个文本节点里的所有 ==...== 替换为 &lt;mark&gt;...&lt;/mark&gt;  function replaceInTextNode(textNode) &#123;    const text = textNode.nodeValue;    if (!text || text.indexOf(&#x27;==&#x27;) === -1) return;    MARK_RE.lastIndex = 0;    let match;    let lastIndex = 0;    const frag = document.createDocumentFragment();    while ((match = MARK_RE.exec(text)) !== null) &#123;      const before = text.slice(lastIndex, match.index);      if (before) frag.appendChild(document.createTextNode(before));      const mark = document.createElement(&#x27;mark&#x27;);      // 只设置 textContent，保持 HTML 安全      mark.textContent = match[1];      frag.appendChild(mark);      lastIndex = MARK_RE.lastIndex;    &#125;    const after = text.slice(lastIndex);    if (after) frag.appendChild(document.createTextNode(after));    // 用片段替换原文本节点    textNode.parentNode.replaceChild(frag, textNode);  &#125;  // 在 root 上处理所有可见文本节点  function process(root = document.body) &#123;    if (!root) return;    const walker = document.createTreeWalker(root, NodeFilter.SHOW_TEXT, &#123;      acceptNode(node) &#123;        if (!node.nodeValue) return NodeFilter.FILTER_REJECT;        if (node.nodeValue.indexOf(&#x27;==&#x27;) === -1) return NodeFilter.FILTER_REJECT;        // 如果仅包含空白（回车空格），跳过        if (node.nodeValue.trim() === &#x27;&#x27;) return NodeFilter.FILTER_REJECT;        return NodeFilter.FILTER_ACCEPT;      &#125;    &#125;, false);    const nodes = [];    while (walker.nextNode()) nodes.push(walker.currentNode);    for (const n of nodes) &#123;      // 跳过 code/pre 等      if (!isInsideSkippedTag(n.parentNode)) &#123;        replaceInTextNode(n);      &#125;    &#125;  &#125;  // 在初次加载时运行一次  function onReadyRun() &#123;    process();  &#125;  if (document.readyState === &#x27;loading&#x27;) &#123;    document.addEventListener(&#x27;DOMContentLoaded&#x27;, onReadyRun);  &#125; else &#123;    onReadyRun();  &#125;  // swup 支持：  // 1) 如果存在全局 swup 实例并且有 on 方法，使用它  // 2) 兼容 swup 自定义 DOM 事件（document 上的 &#x27;swup:contentReplaced&#x27;）  if (window.swup &amp;&amp; typeof window.swup.on === &#x27;function&#x27;) &#123;    try &#123; window.swup.on(&#x27;contentReplaced&#x27;, () =&gt; process()); &#125; catch (e) &#123; /* ignore */ &#125;  &#125;  document.addEventListener(&#x27;swup:contentReplaced&#x27;, () =&gt; process());  // 兜底：监听 DOM 的新插入（节流）  let idleTimer = null;  const observer = new MutationObserver(() =&gt; &#123;    if (idleTimer) clearTimeout(idleTimer);    idleTimer = setTimeout(() =&gt; &#123;      process();      idleTimer = null;    &#125;, 60);  &#125;);  // 观察整个文档的子节点变化（轻量级配置）  observer.observe(document.documentElement || document.body, &#123; childList: true, subtree: true &#125;);  // 可选：暴露一个手动触发的函数，方便调试 / 在控制台直接调用  window.__applyDoubleEqualsMark = process;&#125;)();\n\n","categories":["Hexo"],"tags":["Hexo"]},{"title":"解决Tauri2打包失败的问题","url":"/tauri2/Tauri2-Package/","content":"在打包Tauri2程序时会因为下载不了github的部分文件导致失败，结合Github Issue上的回答和大佬的脚本我对解决方案做了些许修改\n创建一个ps1脚本，脚本内容如下：\n$ghproxy=&quot;https://ghproxy.net/&quot; #这里是ghproxy加速链接，改成别的也可以$wix311_binaries=$ghproxy+&quot;https://github.com/wixtoolset/wix3/releases/download/wix3112rtm/wix311-binaries.zip&quot;$nsis_3=$ghproxy+&quot;https://github.com/tauri-apps/binary-releases/releases/download/nsis-3/nsis-3.zip&quot;$NSIS_ApplicationID=$ghproxy+&quot;https://github.com/tauri-apps/binary-releases/releases/download/nsis-plugins-v0/NSIS-ApplicationID.zip&quot;$nsis_tauri_utils=$ghproxy+&quot;https://github.com/tauri-apps/nsis-tauri-utils/releases/download/nsis_tauri_utils-v0.1.1/nsis_tauri_utils.dll&quot;mkdir tempcd tempcurl $wix311_binaries -LO Expand-Archive ./wix311-binaries.zip -DestinationPath ./WixTools314curl $nsis_3 -LO Expand-Archive ./nsis-3.zip -DestinationPath ./NSISmv .\\NSIS\\nsis-3.*\\* .\\NSISrmdir .\\NSIS\\nsis-3.*curl $NSIS_ApplicationID -LOExpand-Archive .\\NSIS-ApplicationID.zip -DestinationPath .\\NSIS-ApplicationIDmv .\\NSIS-ApplicationID\\Release\\* .\\NSIS\\Plugins\\x86-unicodecurl $nsis_tauri_utils -LOmv .\\nsis_tauri_utils.dll .\\NSIS\\Plugins\\x86-unicodemv .\\NSIS ~\\AppData\\Local\\tauri\\NSISmv .\\WixTools314 ~\\AppData\\Local\\tauri\\WixTools314echo &quot;rm temp dir&quot;rm -r .\\NSIS-ApplicationIDrm .\\nsis-3.ziprm .\\NSIS-ApplicationID.ziprm .\\wix311-binaries.zipcd ..rm .\\tempecho &quot;done&quot;\n\n然后pwsh启动脚本就好了，它会自动下载并安装依赖\n","categories":["Tauri 2"],"tags":["Tauri 2","Rust","Blazor"]},{"title":"建站纪念","url":"/tittle-tattle/blog-estab-commemoration/","content":"纪念建站成功\n","tags":["杂谈"]},{"title":"使用OSSQ版本转换后Win+X和右键开始菜单失效解决方法","url":"/tittle-tattle/oosq-no-winX/","content":"\n有些人在用这个版本转换工具的时候会出现无法右键开始菜单和win+x没有反应的问题，这个问题普遍出现在win11预览版和新的win11正式版，即使重置系统也不管用，我能查到的方法也都试无无果，都是只能重装系统 \n我也是在询问作者后知道了问题所在，根本原因是微软在一次win11更新后更改了”C:\\Windows\\System32\\sppui&quot;文件夹下的文件权限，使其从Administer变成了System，导致了换版本软件换版本后win+x菜单失效\n\n具体解决方案是用纯净版win11的相应文件去替换这个文件夹下的文件并在cmd管理员下输“cscript.exe %windir%\\system32\\slmgr.vbs &#x2F;rilc”等待操作完成后即可解决\n\n\n\n作者也做出了懒人工具发在了官网，可以在更新日志里找到然后下载使用，OSSQ版本转换官网 这是软件的官网\n\n","tags":["Windows","OOSQ"]},{"title":"最强自制第五人格BP展示软件（没有之一）","url":"//id5/bpsys/bp-sys-wpf/","content":"\n\n\n介绍作者：零风PLFJY 第五人格ASG赛事组导播 QQ：3424127335\n注意事项：请务必把软件解压后的内容放在单独的文件夹内，如果造成数据丢失，后果自负（更新器的原理是下载更新包“new_bpsys.7z”后删除目录下除了7z、Resource、new_bpsys.7z以外的全部文件然后解压更新包）\n本软件禁止商用\n软件简介本软件采用.Net 8.0框架编写，界面为WPF框架，由C#编写\n当前版本使用的UI是IVL 2023秋季赛的全套BP UI\n赛制为IVL 2023秋季赛的半全局BP BO5赛制\n如需修改UI，可以等比例修改文件夹下的&#x2F;Resource&#x2F;gui&#x2F;文件夹内的图片进行修改\n当前演示用的版本为V2.2\n本软件已在Github开源：PLFJY&#x2F;bp-sys-wpf\n下载地址：比较符合文章的版本：https://plfjy.lanzouq.com/ie1Q11tt7cgf\n新版UI版本：https://plfjy.lanzouq.com/icsEH255s13a（V3.0.1，和介绍里面有一些不同，不过大体类似）\nBP模块：\n角色展示： 一个下拉组合框都可以输入角色名称的拼音首字母来检索，按下Tab键补全，同时Tab键也是将该框内的角色更新到前台界面的触发按键，只有按下了Tab键对应的图片才会出现在前台界面 （注：26号守卫的拼音首字母为bb即“邦邦”，是个特殊值，主要是为了自己使用方便），正确操作的话对应的下拉框下方会显示对应角色的头像\n关于pick求生者预览图下方的数字键：这个是进入游戏后将选手与使用角色对应使用的，点击相应的数字就会把该位置的角色与按钮上数字对应的位置的角色位置进行互换\n每一回合结束可按下“重置“按钮重置当前角色选择，不会影响地图的BP以及比分系统的比分情况，全局禁选会自动记录到右边的“全局禁选记录”的位置，换边时会自动上屏\n关于全局禁选记录：这个是方便记录全局禁选情况而设定的，会与左边的“全局禁选”联动，可以理解为左边动了右边会动，右边动了左边不动，可以在选手选择完前两手角色时在右边记录上这局的前两手选择\n\n地图BP展示： 这个就没什么好说的，就普遍理性而言不难理解\n\n\n队伍信息（包括队伍名称、队伍LOGO及选手ID）：在”队伍名称“处的文本框输入队伍名称后按下回车键确定以上传至前台画面，不按下回车的话前台界面是不会显示队伍名称的，在对应队伍的区域按下”编辑选手列表“可跳转至选手ID编辑界面，在这个界面里只需要输入选手的名称即可，队伍的名称会在前台自动合成进去。编辑好之后记得按”保存并返回“不要直接关闭窗口，不然不会保存，下次打开就没有了！\n关于后台主界面选手名称旁边的那些数字按钮：这个也是将选手与使用角色对应使用的，点击相应的数字就会把该位置的选手与按钮上数字对应的位置的选手位置进行互换\n\nBan位数量设定： 这个也没啥好说的，勾就是有这个Ban位，取消就是没有这个Ban位，也就是Ban位会被锁住，此时对应的下拉框也会被禁用\n过场画面： 在后台键入的选择的角色也会被同步到过场画面中，这个界面中选手名字的顺序与角色的顺序与前台窗口一致\n\n比分模块：\n比分模块是独立于上面的BP模块的，当然换边的时候是联动的就是了，你可以选择不打开，不打开时BP前台的比分是不显示的\n\n比分系统中，对应的对局结果是当局的对局结果，注意：需要先按下结果再换边，不然两边比分是错的，当然如果错了是可以使用手动面板进行修正的\n注：后台还会显示总小比分，方便最后判断队伍胜利情况\n\n比分在游戏内画面时的显示可以使用”游戏内比分“的两个窗口显示，一个是求生者方选手队伍的，一个是监管者方选手队伍的\n\n\n我还开发了一个界面用于显示各个场次的比分情况，这个是完全独立于前面那个比分后台的，所以需要单独操作，使用上显而易见我也不需要过多讲解\n\n\n\n这个软件我会长期维护，有新版本的话启动软件时会提醒你，彼时可以前往右下角的关于界面进行更新\n\n\n一些特殊的说明： 这个软件的根目录结构分为下面几个文件夹：7z、pic、Resource\n7z：里面的7zip简易版是用于解压更新包的，如果删除软件将无法使用自动更新\npic：里面存放了所有的角色立绘资源、地图展示资源，如果删除会导致软件使用时找不到对应图片而崩溃\nResource：里面还有一个gui文件夹，用于存放软件前台的UI，可以通过修改文件夹内的图片实现界面自定义，另外一个Config.ini文件可以修改前台界面的文字颜色，详细的文件里面有注释说明，颜色代码错误或者gui内图片文件缺失的话都会导致软件崩溃\n总的来说改可以，都别乱删否则软件崩了不怪我\n\n使用要求\n请使用原生OBS对于本软件的前台界面进行展示\n请使用OBS内的“窗口采集”且选择采集方式为”“BitBlt”，窗口匹配优先级为“窗口标题必须匹配”并取消勾选“显示鼠标指针”\n对于源使用滤镜添加“色值”，关键颜色为“绿色”，相似度调整为刚刚好看不到绿色即可（多了会把要展示的也扣没了）\n写在最后： 建议安装“汉仪第五人格体”、“华康POP1体W5”、“得意黑”字体以达到更好的显示效果，不然会很丑，前两款字体可以在第五人格Wiki下方的“字体”处找到，后一款可在B站直接搜索到，由oooooohmygosh大佬制作\n","categories":["第五人格","bp软件"],"tags":["第五人格","bp软件","C#","WPF",".Net"]},{"title":"第五人格BP展示软件【已停止维护】","url":"/id5/bpsys/idv-bp-asg-e/","content":"本项目已停止维护，新作传送门 &#x3D;&#x3D;&gt;bp-sys-wpf\n\n\n作者：PLFJY  第五人格ASG赛事组导播  QQ：3424127335\n本软件禁止商用\n软件简介：\n软件是由易语言5.9.3编写，目前版本（V4.6）仅调用了“彗星真彩模块”用于显示图片，将来版本会调用“精易模块”编写API填充选手ID的功能\n当前版本使用的UI是基于IVL 2022秋季赛更改，为ASG赛事定制版本，如需修改UI，可以等比例修改文件夹下的&#x2F;gui&#x2F;文件夹内的图片进行修改\n本软件基于第四届ASG赛事赛制即第五人格深远的呼唤VI赛制，BO5环境制作，2023 IVL·夏的半全局BP将会于另一个项目进行维护（先挖个坑）\n本软件已于Github开源，欢迎各民间赛事魔改\nhttps://github.com/PLFJY/idv-bp-asg-e\n下载地址：https://github.com/PLFJY/idv-bp-asg-e/releases，下载最新版本的ZIP压缩包完全解压即可\n本软件灵感来源于皮塞冬大佬使用Python制作的BP展示软件 &#x3D;&#x3D;&gt; 自制第五人格bp界面\n\n软件使用介绍：\n\n这个软件功能比较于目前任何一个民间bp展示软件都要多，大致分为“BP系统”与“比分系统”\n\nBP系统：\n先说最基本的角色展示，每一个可下拉的组合框上方都有一个搜索框，可在搜索框里输入相应角色的拼音首拼（注：26号守卫的首拼为“bb”为了自己使用方便，祭司的首拼为“js1”，教授的首拼为“js2”），在下方组合框显示出正确的角色时按下回车即可将结果上传到前台画面，同时相应组合框下方也会出现相应角色的头像（如果是ban就是黑白头像，如果是pick就是彩色头像）。\n关于pick求生者下方预览图下面的数字键：这个是进入游戏后将选手与使用角色对应使用的，点击相应的数字就会把该角色的图片与相应位置角色的图片进行互换\n\n地图BP画面可在直播间闲置画面的左下角放置，没必要放在角色BP阶段的画面展示\n关于计时器：计时器区域的文本框是输入倒计时时间的，输入好后按“开始”则会从这个数字开始倒数，到0即止，按下“停止”则会隐藏前台的计时器显示（手慢、手残党可以不使用这个功能）\n每一回合结束可按下“重置“按钮重置当前角色选择（不会影响地图的BP以及比分系统的比分情况）\n“ban位数量设定面板”则可以设定当前ban位数量\n\n注：这个软件的所有文本框都需要按下回车键内容才会生效，选手ID有自动填充功能，目前只开发了占位填充（全部选手名称变为Player），API填充还在开发中，命名详细规则之后会写在Github的README.md中\n\n同时BP主前台界面的内容会同步至过场画面的窗口中，配合OBS叠加“name”窗口展示选手ID即可达到官方的展示效果。（彗星真彩控件必须最上，所以ID显示只能新弄个窗口）\n\n\n\n比分系统\n比分系统是这个软件一个独立的分支，如需使用，点击后台界面里的“打开比分面板“按钮即可打开比分系统\n\n\n比分系统分为半自动化和手动控制（一般使用半自动化就行了，手动面板一般是点错了想要复原用的），半自动化控制在对局结束后，点击“换边”按钮前选择当前对局结果，一个回合结束后点击大比分结算就能自动结算当前比分，按下”总清零“可以全部重置\n当然，比分系统也准备了游戏内画面的比分显示，分别由两个窗口展示，方便OBS的捕获\n“游戏内比分求生者”窗口放在求生者方的位置，“游戏内比分监管者”窗口放在监管者方的位置（即左上角和右上角，当然你想放哪里其实都可以），游戏内画面显示窗口会同步队伍名称、队伍LOGO、当前比分。\n注：后台还会显示总小比分，方便最后判断队伍胜利情况\n\n\n\n使用须知\n如您想要分享&#x2F;修改本软件，请务必将修改过后的版本进行开源\n队伍LOGO必须为PNG格式，否则会出现显示错误（彗星真彩控件的锅）\n如果下载后发现软件不见了，请检查杀毒软件的保护历史记录，并将该软件加入信任区（易语言老是被搞，习惯了都）\n运行需求\n使用Windows 10 1903以上的系统运行（以下的系统我不保证可以正常运行），使用前请完全解压压缩包，并安装目录下的两个字体文件以达到最佳的使用效果\n使用要求\n请使用原生OBS对于本软件的前台界面进行展示\n请使用OBS内的“窗口采集”且选择采集方式为”“BitBlt”，窗口匹配优先级为“窗口标题必须匹配”并取消勾选“显示鼠标指针”\n对于源使用滤镜添加“色值”，关键颜色为“绿色”，相似度调整为刚刚好看不到绿色即可（多了会把要展示的也扣没了）\n","categories":["第五人格","bp软件"],"tags":["第五人格","bp软件","易语言"]}]