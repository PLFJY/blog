[{"title":"KNN 的浅薄学习笔记","url":"/KNN-shallow-learning-note/","content":"今天了解了一下机器学习，看到了KNN这种算法，因为没搞懂，所以打算把学习过程写成博文辅助自己理解\n代码参考 kaggle 上的 Handwritten digits Classification(Using KNN ) 和 Movie Ratings and Recommendation using KNN\n这是啥？KNN，全称 “ k-nearest neighbor classification”，是一种机器学习算法，它是一种基于分类的有监督学习方式，核心思想是“相似样本有相似输出”，从一大堆数据集中进行训练，所以会有训练集，和测试集，一般是三七开或者二八开，训练集会把样本和标记全部给到模型，然后库比如 scikit-learn 或者 pytorch 会对数据进行处理，或者你可以手动实现，然后你给它个新的值就能做预测。其中KNN中的 K 代表的是 k 值，表示这个新的东西临近的样本的个数，k 值会直接影响模型判断的准确率，如果 k 值过大可能就欠拟合，也就是没找到规律；k 值过小就是过拟合，简单说就是新数据的不认识，只认识训练数据，接下来是实现和使用过程\n怎么实现？使用现有库以 Scikit-learn 举例，首先拿到数据，对数据进行预处理，学习的话一般数据会从数据集的库里拿，比如 scikit-learn自己的数据集 ，具体数据集对应的使用方法都在API文档里面，我们拿这个Handwritten digits Classification(Using KNN )的代码来做例子：\n首先是数据导入和预处理\nfrom sklearn import datasets # 从库里获取数据集from sklearn.cross_validation import train_test_split  # 用于数据集拆分（注意：新版本sklearn已移至model_selection）mnist = datasets.load_digits() # 加载MNIST手写数字数据集，这个就是原始数据# 拆分数据，测试集和训练集 2.5 7.5开(trainData, testData, trainLabels, testLabels) = train_test_split(    np.array(mnist.data),  # 图像数据（反正是处理过的）    mnist.target,  # 标签（0-9的数字）    test_size=0.25,  # 测试集占比    random_state=42  # 保证复现结果的固定随机数种子)# 额外从训练集拿出来的验证集，和训练集一九开(trainData, valData, trainLabels, valLabels) = train_test_split(    trainData,  # 上一步得到的训练集数据    trainLabels,  # 上一步得到的训练集标签    test_size=0.1,  # 验证集占比（相对于当前训练集）    random_state=84  # 保证复现结果的固定随机数种子)# 所以总结下来：# trainData 是训练数据; trainLabels 是训练数据的答案# testData 是测试数据; testLabels 是测试数据的答案# valData 是验证数据; valLabels 是验证数据的答案# 然后下面的代码是拿训练集和验证集来做 k 值尝试\n\n然后是使用 scikit-learn 库来做机器学习，第一步是弄个 k 值预设表 kVals，之后的 k 值就会从这里一个一个试，试到满意为止\nkVals = range(1, 30, 2) # 1 ~ 30 之间的所有奇数，换成C#也就是 Enumerable.Range(1, 30).Where(x =&gt; x%2 != 0);accuracies = [] # 存储准确率的列表\n\n这里是最重要的地方，接下来就是一个一个试 k 值了\n# 导入几个新的工具from sklearn.neighbors import KNeighborsClassifier  # K近邻分类器，说白了就是你的模型for k in kVals: # 这里源代码不好，我做了一些改编    model = KNeighborsClassifier(n_neighbors=k)  # 初始化模型，设置模型基本参数 (k值)    model.fit(trainData, trainLabels)  # 拟合数据（其实就是训练模型，scikit-learn 帮你实现了）\t        score = model.score(valData, valLabels) # 拿验证集去测一下训练好的模型，这一步也是 scikit-learn 实现好的，直接出准确率    print(f&#x27;k值是&#123;k&#125;, 准确率是&#123;score&#125;&#x27;) # 打印一下调试，不用管    accuracies.append(score)  # 把得到的准确率存下来（话说为啥不用字典）\n\n试出来所有 k 值对应的准确率后就该正式训练模型了\n# 导入一下新的工具import numpy as npi = np.argmax(accuracies)  # 利用 numpy 的 argmax 方法获取到最高的准确率的 indexprint(f&#x27;k=&#123;kVals[i]&#125;的时候准确率最高，准确率是&#123;accuracies[i]&#125;&#x27;) # 打印一下调试，不用管# 用最新的 k 值训练模型model = KNeighborsClassifier(n_neighbors=kVals[i])model.fit(trainData, trainLabels)score = model.score(testData, testLabels) # 拿测试集去测一下训练好的模型，看看准确率print(f&#x27;最终模型的准确率是&#123;score&#125;&#x27;) # 最后看看准确率\n\n差不多了，后面都是无关紧要的验证，最重要的是前面的实现，那么接下来就是手动实现的案例了\n手动实现Movie Ratings and Recommendation using KNN 的代码使用的是手动实现的方式，它实现了一个电影评价系统，开始它先导入了两张表\nimport pandas as pd # 用来导入表的库movies = pd.read_csv(&#x27;../input/tmdb-movie-metadata/tmdb_5000_movies.csv&#x27;) # 导入电影信息的表credits = pd.read_csv(&#x27;../input/tmdb-movie-metadata/tmdb_5000_credits.csv&#x27;) # 导入工作人员信息的表\n\n接着的部分是利用输出辨别数据结构，不是KNN讨论的重点，所以我们略过这一部分\n接下来合并了两张表方便后续处理\nmovies = movies.merge(credits,left_on=&#x27;id&#x27;,right_on=&#x27;movie_id&#x27;,how=&#x27;left&#x27;)movies = movies[[&#x27;id&#x27;,&#x27;original_title&#x27;,&#x27;genres&#x27;,&#x27;cast&#x27;,&#x27;vote_average&#x27;,&#x27;director&#x27;,&#x27;keywords&#x27;]]\n\n下面是它核心的算法部分，用于从多个维度计算两个电影之间的距离\nfrom scipy import spatialdef Similarity(movieId1, movieId2):    # 分别提取两个电影的特征    a = movies.iloc[movieId1]    b = movies.iloc[movieId2]        # 计算各特征向量的距离，使用的余弦    genresA = a[&#x27;genres_bin&#x27;]    genresB = b[&#x27;genres_bin&#x27;]    genreDistance = spatial.distance.cosine(genresA, genresB)  # 类型距离        scoreA = a[&#x27;cast_bin&#x27;]    scoreB = b[&#x27;cast_bin&#x27;]    scoreDistance = spatial.distance.cosine(scoreA, scoreB)  # 评分距离        directA = a[&#x27;director_bin&#x27;]    directB = b[&#x27;director_bin&#x27;]    directDistance = spatial.distance.cosine(directA, directB)  # 导演距离        wordsA = a[&#x27;words_bin&#x27;]    wordsB = b[&#x27;words_bin&#x27;]    wordsDistance = spatial.distance.cosine(wordsA, wordsB)  # 关键词距离(原代码此处笔误，已修正)        # 总距离为各特征距离之和    return genreDistance + directDistance + scoreDistance + wordsDistance\n\n所以我们可以用下面的方式来调用这个函数\nSimilarity(3,160) #checking similarity between any 2 random movies\n\n下面，它定义了一个分数预测器 predic_score(name) 函数，这里面是模型训练和获取预测值的相关逻辑，详细拆解如下:\n\n这里是最重要的地方，在这个函数里面，它先定义了一个“获取邻居”的方法\ndef getNeighbors(baseMovie, K):    distances = []    # 遍历所有电影，计算与目标电影的距离    for index, movie in movies.iterrows():         if movie[&#x27;new_id&#x27;] != baseMovie[&#x27;new_id&#x27;].values[0]:  # 排除自身            dist = Similarity(baseMovie[&#x27;new_id&#x27;].values[0], movie[&#x27;new_id&#x27;])            distances.append((movie[&#x27;new_id&#x27;], dist))  # 以(电影ID，距离)的tuple来存储        # 按距离升序排序（距离越小越相似）    distances.sort(key=operator.itemgetter(1))        # 取前K个最近邻    neighbors = []    for x in range(K):        neighbors.append(distances[x])    return neighbors\n\n下面是获取预测值的步骤，这里我已经把 getNeighbors(baseMovie, K) 抽象到上面了，方便理解\ndef predict_score(name):    # 找到符合目标电影关键词的列表    new_movie = movies[movies[&#x27;original_title&#x27;].str.contains(name)].iloc[0].to_frame().T    print(&#x27;Selected Movie: &#x27;, new_movie.original_title.values[0])        K = 10  # 取10个邻居，拟定 k 值为 10，实际并没有经过过测试    neighbors = getNeighbors(new_movie, K)  # 获取最近的10个邻居        # 输出匹配到的10个结果    print(&#x27;Recommended Movies: &#x27;)    avgRating = 0    for neighbor in neighbors:        avgRating += movies.iloc[neighbor[0]][&#x27;vote_average&#x27;]  # 累加近邻评分        print(f&quot;&#123;movies.iloc[neighbor[0]][&#x27;original_title&#x27;]&#125; | Genres: &#123;str(movies.iloc[neighbor[0]][&#x27;genres&#x27;]).strip(&#x27;[]&#x27;).replace(&#x27; &#x27;,&#x27;&#x27;)&#125; | Rating: &#123;movies.iloc[neighbor[0]][&#x27;vote_average&#x27;]&#125;&quot;) # 打印匹配到的电影的详情        # 预测评分（近邻平均评分）这步已经是多余了，主要是根据KNN的思想，假设相似的电影具有相似的属性，那么作用是，如果电影未上映，则可以预测出一个可能的评分    avgRating /= K    print(f&#x27;\\nThe predicted rating for &#123;new_movie[&quot;original_title&quot;].values[0]&#125; is: &#123;avgRating&#125;&#x27;)    print(f&#x27;The actual rating for &#123;new_movie[&quot;original_title&quot;].values[0]&#125; is &#123;new_movie[&quot;vote_average&quot;].values[0]&#125;&#x27;)\n\n这就是关于这个的全部解析了\n下面是个人有关第二个手动实现的代码的一些想法\n\n\n结合面向对象编程那么我们现在看到，这个代码的遍历方式和比较方式是很笨拙的，可扩展性不高，要是再有多一点东西，基本上就能感觉到修改极其吃力，并且我们理解也需要花很高的成本\n下面这个音乐分类的例子采用了面向对象的思想\nimport randomfrom typing import List, Dict, Tuple, Optionalfrom py_linq import EnumerableGENRES = [&quot;classical&quot;, &quot;rock&quot;, &quot;jazz&quot;, &quot;pop&quot;, &quot;hiphop&quot;, &quot;electronic&quot;]ARTISTS = &#123;    &quot;classical&quot;: [&quot;Bach&quot;, &quot;Mozart&quot;, &quot;Beethoven&quot;, &quot;Chopin&quot;, &quot;Tchaikovsky&quot;],    &quot;rock&quot;: [&quot;The Beatles&quot;, &quot;The Rolling Stones&quot;, &quot;Queen&quot;, &quot;AC/DC&quot;, &quot;Nirvana&quot;],    &quot;jazz&quot;: [&quot;Miles Davis&quot;, &quot;Louis Armstrong&quot;, &quot;Duke Ellington&quot;, &quot;Charlie Parker&quot;],    &quot;pop&quot;: [&quot;Taylor Swift&quot;, &quot;Ed Sheeran&quot;, &quot;Rihanna&quot;, &quot;Bruno Mars&quot;],    &quot;hiphop&quot;: [&quot;Jay-Z&quot;, &quot;Kendrick Lamar&quot;, &quot;Eminem&quot;, &quot;Drake&quot;],    &quot;electronic&quot;: [&quot;Deadmau5&quot;, &quot;Daft Punk&quot;, &quot;Avicii&quot;, &quot;Skrillex&quot;]&#125;KEYS = [&quot;C Major&quot;, &quot;D Major&quot;, &quot;E Major&quot;, &quot;F Major&quot;, &quot;G Major&quot;, &quot;A Major&quot;, &quot;B Major&quot;,        &quot;C Minor&quot;, &quot;D Minor&quot;, &quot;E Minor&quot;, &quot;F Minor&quot;, &quot;G Minor&quot;, &quot;A Minor&quot;, &quot;B Minor&quot;]LANGUAGES = [&quot;English&quot;, &quot;中文&quot;, &quot;한국어&quot;, &quot;日本語&quot;, &quot;Español&quot;, &quot;Русский язык&quot;, &quot;اللغة العربية&quot;, &quot;Français&quot;]class Music:    def __init__(self, title, genre, bpm, artist, key, lang, complexity, is_labeled = False):        self.title = title        self.genre = genre        self.bpm = bpm        self.artist = artist        self.key = key        self.lang = lang        self.complexity = complexity        self.is_labeled = is_labeled    def __repr__(self) -&gt; str:        return f&quot;&#123;self.title&#125;: &#123;self.genre&#125; (BPM: &#123;self.bpm:.1f&#125;, Artist: &#123;self.artist&#125;)&quot;        def artist_diff(self, other):        if(self.artist == other.artist):            return 0                    self_artist_key = (Enumerable(ARTISTS.items())                           .where(lambda x : self.artist in x[1])                           .select(lambda x : x[0])                           .first())                return 1 if other.artist in ARTISTS[self_artist_key] else 2            def genres_diff(self, other):        return 0 if self.genre == other.genre else 2        def keys_diff(self, other):        return 0 if self.key == other.key else 2            def langs_diff(self, other):        return 0 if self.lang == other.lang else 2        def bpm_diff(self, other):        return abs(self.bpm - other.bpm)        def distance(self, other):        return self.artist_diff(other) + self.bpm_diff(other) + self.genres_diff(other) + self.keys_diff(other) + self.langs_diff(other)class Music_Collection:    def __init__(self, l):        self.l = l    def find_neighbors(self, music, num):        distances = []        for item in self.l:            if(item == music):                continue            distances.append((music.distance(item), item))        distances.sort(key=lambda x : x[0])        return [item for (dist, item) in distances[:num]]# Generated By AIclass MusicDataGenerator:    &quot;&quot;&quot;静态音乐数据生成器类，提供静态方法生成符合特征范围的随机数据集&quot;&quot;&quot;    # 静态方法无需实例化即可调用    @staticmethod    def set_seed(seed: int) -&gt; None:        &quot;&quot;&quot;设置随机种子，用于复现结果&quot;&quot;&quot;        random.seed(seed)        @staticmethod    def generate_music(genre: str, title: str, is_labeled: bool = True) -&gt; Music:        GENRE_FEATURE_RANGES = &#123;        &quot;classical&quot;: &#123;&quot;bpm_min&quot;: 60, &quot;bpm_max&quot;: 120, &quot;complexity&quot;: (7, 10)&#125;,        &quot;rock&quot;: &#123;&quot;bpm_min&quot;: 100, &quot;bpm_max&quot;: 160, &quot;complexity&quot;: (5, 8)&#125;,        &quot;jazz&quot;: &#123;&quot;bpm_min&quot;: 80, &quot;bpm_max&quot;: 140, &quot;complexity&quot;: (6, 10)&#125;,        &quot;pop&quot;: &#123;&quot;bpm_min&quot;: 100, &quot;bpm_max&quot;: 130, &quot;complexity&quot;: (3, 6)&#125;,        &quot;hiphop&quot;: &#123;&quot;bpm_min&quot;: 80, &quot;bpm_max&quot;: 110, &quot;complexity&quot;: (4, 7)&#125;,        &quot;electronic&quot;: &#123;&quot;bpm_min&quot;: 120, &quot;bpm_max&quot;: 180, &quot;complexity&quot;: (5, 9)&#125;        &#125;        &quot;&quot;&quot;生成一首特定类型的音乐&quot;&quot;&quot;        if genre not in GENRE_FEATURE_RANGES:            raise ValueError(f&quot;Unknown genre: &#123;genre&#125;&quot;)                    features = GENRE_FEATURE_RANGES[genre]                # 在类型特征范围内生成BPM        bpm = random.uniform(features[&quot;bpm_min&quot;], features[&quot;bpm_max&quot;])                # 从该类型的艺术家列表中随机选择        artist = random.choice(ARTISTS[genre])                # 随机选择音调和语言        key = random.choice(KEYS)        lang = random.choice(LANGUAGES)                # 生成复杂度        complexity = random.uniform(features[&quot;complexity&quot;][0], features[&quot;complexity&quot;][1])                return Music(            title=title,            genre=genre,            bpm=bpm,            artist=artist,            key=key,            lang=lang,            complexity=complexity,            is_labeled=is_labeled        )        @staticmethod    def generate_by_genre(genre: str, count: int = 1, start_index: int = 0) -&gt; List[Music]:        &quot;&quot;&quot;生成指定数量的特定类型音乐&quot;&quot;&quot;        music_list = []        for i in range(count):            title = f&quot;&#123;genre&#125;_track_&#123;start_index + i + 1&#125;&quot;            music = MusicDataGenerator.generate_music(genre, title)            music_list.append(music)        return music_list        @staticmethod    def generate_balanced_dataset(total_count: int = 1) -&gt; List[Music]:        &quot;&quot;&quot;生成均衡的数据集，每个类型数量大致相同&quot;&quot;&quot;        genre_count = len(GENRES)        base_count = total_count // genre_count        remainder = total_count % genre_count                dataset = []        current_index = 0                for i, genre in enumerate(GENRES):            # 分配数量，处理余数            count = base_count + (1 if i &lt; remainder else 0)            genre_tracks = MusicDataGenerator.generate_by_genre(genre, count, current_index)            dataset.extend(genre_tracks)            current_index += count                # 打乱数据集顺序        random.shuffle(dataset)        return dataset        @staticmethod    def generate_unknown_music(count: int = 1) -&gt; List[Music]:        &quot;&quot;&quot;生成指定数量的未分类音乐&quot;&quot;&quot;        unknowns = []        for i in range(count):            # 随机选择一个类型作为基础，但不设置标签            genre = random.choice(GENRES)            title = f&quot;unknown_track_&#123;i+1&#125;&quot;            music = MusicDataGenerator.generate_music(genre, title, is_labeled=False)            music.genre = &quot;unknown&quot;  # 清除标签            unknowns.append(music)        return unknownsif(__name__ == &quot;__main__&quot;):    # random seed insure reproducible    MusicDataGenerator.set_seed(45)    training_data = MusicDataGenerator.generate_balanced_dataset(1000)    collection = Music_Collection(training_data) # training data generate    # unknown music genrate    # unknown_tracks = MusicDataGenerator.generate_by_genre(&quot;pop&quot;)    # unknown_tracks = MusicDataGenerator.generate_by_genre(&quot;classical&quot;)    # unknown_tracks = MusicDataGenerator.generate_by_genre(&quot;rock&quot;)    unknown_tracks = MusicDataGenerator.generate_by_genre(&quot;electronic&quot;)    print(f&quot;Unknown tracks detail is:&#123;unknown_tracks[0]&#125;&quot;)    print(&quot;\\nFound Tracks:&quot;)    found_tracks = collection.find_neighbors(unknown_tracks[0], 10)    for track in found_tracks:        print(track)\n\n","tags":["python","machine learning"]},{"title":"Hexo插入图片踩坑记录","url":"/Hexo/Hexo-insert-image/","content":"总算是配置好博客了，这个图片问题搞了我半个小时，现在终于搞定了，本来就不麻烦，其实站在巨人的肩膀上就好了，这样能保证Typora &#x2F; VS Code编辑本地预览有效同时网页上也预览没问题_config.yml\npost_asset_folder: truemarked:  prependRoot: true  postAsset: true\nnpm install hexo-asset-img --save\n这里贴一下大佬的仓库：yiyungent&#x2F;hexo-asset-img引用图片的时候像这样\n![](&lt;assets_folder_name&gt;/&lt;file_name&gt;.jpg)\n完事\n","categories":["Hexo"],"tags":["Hexo"]},{"title":"AP CSA 00-About AP Computer Science A","url":"/ap-csa/00-about-ap-csa/","content":"我尽量每个问题两句话内说完\nQ: 考什么？A: Java基础\nQ: Java是什么？A: 一种面向对象 (Object oriented programming 简称 OOP) 编程语言，常用于网站后端和安卓软件开发，其它的用处你要用也能用，知名的沙盒游戏Minecraft就是它写的\n至于面向对象是什么……我后面会讲\nQ: 考数据结构之类的复杂的东西吗？A: 不，会基础就好，最难也就递归了\nQ: 难学吗？A: 个人认为理解了本质就很好上手，下面是考试大纲，我接下来的文章会按照我自己的新编排序来讲，理解完再回去看大纲然后刷题，结束\n考试大纲\n","categories":["AP CSA"],"tags":["AP","Java","AP CSA"]},{"title":"AP CSA 01-一些基础（考试不考，但要讲）","url":"/ap-csa/01-basic-concept/","content":"写在前头: 学习编程不要妄想自己什么都能一行行搞懂，所有无法理解的东西且本文我说了你不用知道的东西完全不用在乎，因为一时半会影响不了你的学习，学到后面有了一定的知识积累或者渐渐理解编程的本质之后，通过查阅文档，就能自然而然的理解那些当年不知道的内容\n先介绍一些编程基础概念：1. 编译指把你写的代码转换为机器码的过程，但是我需要强调的是现在编程语言普遍分为3种，运行效率由高到低如下：\n\n编译型，指你写的代码会被完全编译成汇编语言，至于汇编是啥你不用管，你只需要知道这玩意跟000111的二进制是差不多一个级别的底层玩意就行，例如：C&#x2F;C++、Rust、Go\n半编译型（Java所在的类型），指你写的代码会被翻译成一种中间语言，交给运行器运行，运行器看这种中间语言效率相对很高，例如：Java、C#\n解释型（又称脚本型），指你写的代码会被运行器一行一行看着执行，效率最低，例如：Python、JavaScript\n\n2. 运行指你的代码被实际跑在设备上的过程\n3. 环境代码不是能凭空编译的，后面两种类型的编程语言也不是能独立运行的，需要一个运行器或者编译器，电脑里有这种对应的东西就叫环境\n属于Java的特殊概念Java因为是半编译型语言，所以是跑在一个叫做 JVM (Java Virtual Machine) 的虚拟机上的，这里又有同学要问了，”虚拟机是什么”，了当的说就是一个不真实的环境，上面说了环境是装在你电脑上的，那么不直接跑在你电脑上的都叫虚拟机，Java为了能一套代码能在各种平台上运行，比如Windows电脑、Mac电脑、Linux电脑、Android手机、IOS手机，这个叫做跨平台，所以给每个设备都准备了一种虚拟机，你的代码不用变，就能直接依靠这个虚拟机跑在各个不同的设备上，结合前面的东西图示如下\n\n图标资源来自：icons8\n接下来是 JAVA 的 两种工具类型：\n\nJRE (Java Runtime Environment) ，只有 JVM，没有上面的编译器，只能用来跑，没法编译，这个是给用户装的\nJDK (JAVA Development Kit)，既有 JVM 还有编译器，已经包含了 JRE 了，写代码装这个\n\n配环境接下来是装 JDK 配环境，直接看别人写好的文章就好了，我不造轮子了\n\nWindows\nMac\nLinux\n\n然后是你写代码的地方，你总不可能拿记事本写不是？\n下载个 VS Code -&gt; https://code.visualstudio.com/Download\n然后调中文这一步我就不教了，都要考 AP 了还调什么中文\n左边 Extensions 打开，搜索 Java，然后安装第一个就行\n写代码点开左上角 Files -&gt; Open Folder 选一个你喜欢的地方确定，然后左边上面那里把 Explore 打开，右键 Explore 的空白处 New Java File -&gt; Class...，顶上会弹出来让你写文件名，把文件名敲进去回车，你应该能看到这个\npublic class &lt;你刚刚敲进去的文件名&gt; &#123;    &#125;\n\n在这个地方里面直接粘贴下面的代码，现在先不用管，后面的章节我会解释这个什么意思\npublic static void main(String[] args) &#123;        System.out.println(&quot;Hello World&quot;);    &#125;\n\n然后右上角点一下那个小三角▶️，不出意外你应该能看到下面大致长这样：\n\n你看到那个 Hello World 就是成功了\n一定一定要注意的编程中的所有符号全部给我用英文的半角符号，比如逗号，区分一下，， 这个是中文的，, 这个是英文的，中文的是全角符号，会比英文的宽好多，而且会圆润一点，你敲中文的编译器不认识，敲错了没看出来别说你编程是我教的\n以下是容易敲错符号的列表，代码跑不起来的时候请自查符号问题：\n\n\n\n符号名称\n中文符号\n英文符号\n\n\n\n逗号 comma\n，\n,\n\n\n分号 semicolon\n；\n;\n\n\n句点 period\n。\n.\n\n\n小括号 curve\n（ ）\n( )\n\n\n中括号 square bracket\n【 】\n[ ]\n\n\n大括号 bracket\n「 」\n&#123; &#125;\n\n\n感叹号 bang or shriek\n！\n!\n\n\n双引号 double quotes\n“ ”\n&quot; &quot;\n\n\n单引号 single quote\n‘ ’\n&#39; &#39;\n\n\n本章节到此结束\n","categories":["AP CSA"],"tags":["AP","Java","AP CSA"]},{"title":"AP CSA 02-Data Types","url":"/ap-csa/02-data-types/","content":"接下来终于到正式内容了，这里还是按照顺序的，本章节对应 考纲 Unit 1的内容\n认识数据类型首先，什么是数据类型？我们电脑屏幕或者纸上看到的所有东西都有它对应的数据类型，但是计算机不会直接知道你的东西是什么数据，AP考试关注以下这几种数据类型：\n\nint –&gt; 整数\nfloat –&gt; 单精度小数（又称浮点数）（考试不考）\ndouble –&gt; 双精度小数\nboolean –&gt; 中文是啥不重要，知道它只有 true 和 false 两个状态就行\nchar –&gt; 字符（考试不考，但是是下面字符串的组成部分）\nString –&gt; 字符串（重点，后面会单独开一章讲）\nArray –&gt; 数组\nArrayList –&gt; 列表\n\nint (Integer) 整数int 是整数类型，和数学上的定义是一样的，我就不抄 Google 了，这里有几个特性：\n\n默认值是 0\nint 拥有自增自减运算，这个在下一章变量会讲\ndouble 转换为 int 会舍弃后面的小数位数，只保留整数，举个例子，1.5 转成 int 类型则是 1，不存在四舍五入，四舍五入是一个特殊算法，后面会讲，主要用到的就是这个性质\n上限和下限具体值不用记，代码里用 Integer.MAX_VALUE 和Integer.MIN_VALUE 就好了，AP用不着，但是要提一嘴\n\ndouble 小数double是小数类型，又称浮点数类型，和数学上定义一样，不过没有循环小数了，多的部分会存不进去，直接截断，特性如下：\n\n编程中的凡是浮点类型精度都有限，不要妄想通过这个来算账，尤其是精密的东西，有需要可自行Google “高精度”\n没有自增运算\n默认值是 0.0d，d 表示双精度浮点，啥意思也不用管，提一嘴\n前面说过，和 int 之间的类型转换问题，这里是反过来的，int 转 double 完整保留，直接转换即可，比如1 从 int 转换成 double 会变成 1.0 \n上限和下限分别是Double.MIN_VALUE Double.MIN_VALUE，AP也用不着，当了解了\n\nboolean 中文是啥不重要boolean 别的语言里有的又称 bool 类型，中文是啥不重要 (我就算说了它叫布尔你也不知道是干啥的)，它只有 2 个性质：\n\n这种类型只有两种情况，true 或者 false\n前面加上 ! 会取反，比如 !true == false, (1 != 3) == true\n这个是补充知识：编程中 = 指的是赋值操作，不是常规的等于号，下一章讲，要比较相等请使用 ==\n\nString  字符串顾名思义，字符组成的串，在代码里我们通常用双引号扩起来，第一章你应该记得见过像这样的 &quot;Hello World&quot; ，这玩意就叫字符串，这里不详细介绍，后面单独开一章。&#39;A&#39; 这种叫字符char，AP考试不考字符\nArray和 ArrayList这俩货不是最基本的基础数据类型，后面再说，先放着，你一时半会也见不到\n本章节到此结束\n","categories":["AP CSA"],"tags":["AP","Java","AP CSA"]},{"title":"Hexo插入图片踩坑记录","url":"/hexo/Hexo-insert-image/","content":"总算是配置好博客了，这个图片问题搞了我半个小时，现在终于搞定了，本来就不麻烦，其实站在巨人的肩膀上就好了，这样能保证Typora &#x2F; VS Code编辑本地预览有效同时网页上也预览没问题_config.yml\npost_asset_folder: truemarked:  prependRoot: true  postAsset: true\nnpm install hexo-asset-img --save\n这里贴一下大佬的仓库：yiyungent&#x2F;hexo-asset-img引用图片的时候像这样\n![](&lt;assets_folder_name&gt;/&lt;file_name&gt;.jpg)\n完事\n","categories":["Hexo"],"tags":["Hexo"]},{"title":"解决Tauri2打包失败的问题","url":"/tauri2/Tauri2-Package/","content":"在打包Tauri2程序时会因为下载不了github的部分文件导致失败，结合Github Issue上的回答和大佬的脚本我对解决方案做了些许修改\n创建一个ps1脚本，脚本内容如下：\n$ghproxy=&quot;https://ghproxy.net/&quot; #这里是ghproxy加速链接，改成别的也可以$wix311_binaries=$ghproxy+&quot;https://github.com/wixtoolset/wix3/releases/download/wix3112rtm/wix311-binaries.zip&quot;$nsis_3=$ghproxy+&quot;https://github.com/tauri-apps/binary-releases/releases/download/nsis-3/nsis-3.zip&quot;$NSIS_ApplicationID=$ghproxy+&quot;https://github.com/tauri-apps/binary-releases/releases/download/nsis-plugins-v0/NSIS-ApplicationID.zip&quot;$nsis_tauri_utils=$ghproxy+&quot;https://github.com/tauri-apps/nsis-tauri-utils/releases/download/nsis_tauri_utils-v0.1.1/nsis_tauri_utils.dll&quot;mkdir tempcd tempcurl $wix311_binaries -LO Expand-Archive ./wix311-binaries.zip -DestinationPath ./WixTools314curl $nsis_3 -LO Expand-Archive ./nsis-3.zip -DestinationPath ./NSISmv .\\NSIS\\nsis-3.*\\* .\\NSISrmdir .\\NSIS\\nsis-3.*curl $NSIS_ApplicationID -LOExpand-Archive .\\NSIS-ApplicationID.zip -DestinationPath .\\NSIS-ApplicationIDmv .\\NSIS-ApplicationID\\Release\\* .\\NSIS\\Plugins\\x86-unicodecurl $nsis_tauri_utils -LOmv .\\nsis_tauri_utils.dll .\\NSIS\\Plugins\\x86-unicodemv .\\NSIS ~\\AppData\\Local\\tauri\\NSISmv .\\WixTools314 ~\\AppData\\Local\\tauri\\WixTools314echo &quot;rm temp dir&quot;rm -r .\\NSIS-ApplicationIDrm .\\nsis-3.ziprm .\\NSIS-ApplicationID.ziprm .\\wix311-binaries.zipcd ..rm .\\tempecho &quot;done&quot;\n\n然后pwsh启动脚本就好了，它会自动下载并安装依赖\n","categories":["Tauri 2"],"tags":["Tauri 2","Rust","Blazor"]},{"title":"建站纪念","url":"/tittle-tattle/blog-estab-commemoration/","content":"纪念建站成功\n","tags":["杂谈"]},{"title":"使用OSSQ版本转换后Win+X和右键开始菜单失效解决方法","url":"/tittle-tattle/oosq-no-winX/","content":"\n有些人在用这个版本转换工具的时候会出现无法右键开始菜单和win+x没有反应的问题，这个问题普遍出现在win11预览版和新的win11正式版，即使重置系统也不管用，我能查到的方法也都试无无果，都是只能重装系统 \n我也是在询问作者后知道了问题所在，根本原因是微软在一次win11更新后更改了”C:\\Windows\\System32\\sppui&quot;文件夹下的文件权限，使其从Administer变成了System，导致了换版本软件换版本后win+x菜单失效\n\n具体解决方案是用纯净版win11的相应文件去替换这个文件夹下的文件并在cmd管理员下输“cscript.exe %windir%\\system32\\slmgr.vbs &#x2F;rilc”等待操作完成后即可解决\n\n\n\n作者也做出了懒人工具发在了官网，可以在更新日志里找到然后下载使用，OSSQ版本转换官网 这是软件的官网\n\n","tags":["Windows","OOSQ"]},{"title":"最强自制第五人格BP展示软件（没有之一）","url":"//id5/bpsys/bp-sys-wpf/","content":"\n\n\n介绍作者：零风PLFJY 第五人格ASG赛事组导播 QQ：3424127335\n注意事项：请务必把软件解压后的内容放在单独的文件夹内，如果造成数据丢失，后果自负（更新器的原理是下载更新包“new_bpsys.7z”后删除目录下除了7z、Resource、new_bpsys.7z以外的全部文件然后解压更新包）\n本软件禁止商用\n软件简介本软件采用.Net 8.0框架编写，界面为WPF框架，由C#编写\n当前版本使用的UI是IVL 2023秋季赛的全套BP UI\n赛制为IVL 2023秋季赛的半全局BP BO5赛制\n如需修改UI，可以等比例修改文件夹下的&#x2F;Resource&#x2F;gui&#x2F;文件夹内的图片进行修改\n当前演示用的版本为V2.2\n本软件已在Github开源：PLFJY&#x2F;bp-sys-wpf\n下载地址：比较符合文章的版本：https://plfjy.lanzouq.com/ie1Q11tt7cgf\n新版UI版本：https://plfjy.lanzouq.com/icsEH255s13a（V3.0.1，和介绍里面有一些不同，不过大体类似）\nBP模块：\n角色展示： 一个下拉组合框都可以输入角色名称的拼音首字母来检索，按下Tab键补全，同时Tab键也是将该框内的角色更新到前台界面的触发按键，只有按下了Tab键对应的图片才会出现在前台界面 （注：26号守卫的拼音首字母为bb即“邦邦”，是个特殊值，主要是为了自己使用方便），正确操作的话对应的下拉框下方会显示对应角色的头像\n关于pick求生者预览图下方的数字键：这个是进入游戏后将选手与使用角色对应使用的，点击相应的数字就会把该位置的角色与按钮上数字对应的位置的角色位置进行互换\n每一回合结束可按下“重置“按钮重置当前角色选择，不会影响地图的BP以及比分系统的比分情况，全局禁选会自动记录到右边的“全局禁选记录”的位置，换边时会自动上屏\n关于全局禁选记录：这个是方便记录全局禁选情况而设定的，会与左边的“全局禁选”联动，可以理解为左边动了右边会动，右边动了左边不动，可以在选手选择完前两手角色时在右边记录上这局的前两手选择\n\n地图BP展示： 这个就没什么好说的，就普遍理性而言不难理解\n\n\n队伍信息（包括队伍名称、队伍LOGO及选手ID）：在”队伍名称“处的文本框输入队伍名称后按下回车键确定以上传至前台画面，不按下回车的话前台界面是不会显示队伍名称的，在对应队伍的区域按下”编辑选手列表“可跳转至选手ID编辑界面，在这个界面里只需要输入选手的名称即可，队伍的名称会在前台自动合成进去。编辑好之后记得按”保存并返回“不要直接关闭窗口，不然不会保存，下次打开就没有了！\n关于后台主界面选手名称旁边的那些数字按钮：这个也是将选手与使用角色对应使用的，点击相应的数字就会把该位置的选手与按钮上数字对应的位置的选手位置进行互换\n\nBan位数量设定： 这个也没啥好说的，勾就是有这个Ban位，取消就是没有这个Ban位，也就是Ban位会被锁住，此时对应的下拉框也会被禁用\n过场画面： 在后台键入的选择的角色也会被同步到过场画面中，这个界面中选手名字的顺序与角色的顺序与前台窗口一致\n\n比分模块：\n比分模块是独立于上面的BP模块的，当然换边的时候是联动的就是了，你可以选择不打开，不打开时BP前台的比分是不显示的\n\n比分系统中，对应的对局结果是当局的对局结果，注意：需要先按下结果再换边，不然两边比分是错的，当然如果错了是可以使用手动面板进行修正的\n注：后台还会显示总小比分，方便最后判断队伍胜利情况\n\n比分在游戏内画面时的显示可以使用”游戏内比分“的两个窗口显示，一个是求生者方选手队伍的，一个是监管者方选手队伍的\n\n\n我还开发了一个界面用于显示各个场次的比分情况，这个是完全独立于前面那个比分后台的，所以需要单独操作，使用上显而易见我也不需要过多讲解\n\n\n\n这个软件我会长期维护，有新版本的话启动软件时会提醒你，彼时可以前往右下角的关于界面进行更新\n\n\n一些特殊的说明： 这个软件的根目录结构分为下面几个文件夹：7z、pic、Resource\n7z：里面的7zip简易版是用于解压更新包的，如果删除软件将无法使用自动更新\npic：里面存放了所有的角色立绘资源、地图展示资源，如果删除会导致软件使用时找不到对应图片而崩溃\nResource：里面还有一个gui文件夹，用于存放软件前台的UI，可以通过修改文件夹内的图片实现界面自定义，另外一个Config.ini文件可以修改前台界面的文字颜色，详细的文件里面有注释说明，颜色代码错误或者gui内图片文件缺失的话都会导致软件崩溃\n总的来说改可以，都别乱删否则软件崩了不怪我\n\n使用要求\n请使用原生OBS对于本软件的前台界面进行展示\n请使用OBS内的“窗口采集”且选择采集方式为”“BitBlt”，窗口匹配优先级为“窗口标题必须匹配”并取消勾选“显示鼠标指针”\n对于源使用滤镜添加“色值”，关键颜色为“绿色”，相似度调整为刚刚好看不到绿色即可（多了会把要展示的也扣没了）\n写在最后： 建议安装“汉仪第五人格体”、“华康POP1体W5”、“得意黑”字体以达到更好的显示效果，不然会很丑，前两款字体可以在第五人格Wiki下方的“字体”处找到，后一款可在B站直接搜索到，由oooooohmygosh大佬制作\n","categories":["第五人格","bp软件"],"tags":["第五人格","bp软件","C#","WPF",".Net"]},{"title":"第五人格BP展示软件【已停止维护】","url":"/id5/bpsys/idv-bp-asg-e/","content":"本项目已停止维护，新作传送门 &#x3D;&#x3D;&gt;bp-sys-wpf\n\n\n作者：PLFJY  第五人格ASG赛事组导播  QQ：3424127335\n本软件禁止商用\n软件简介：\n软件是由易语言5.9.3编写，目前版本（V4.6）仅调用了“彗星真彩模块”用于显示图片，将来版本会调用“精易模块”编写API填充选手ID的功能\n当前版本使用的UI是基于IVL 2022秋季赛更改，为ASG赛事定制版本，如需修改UI，可以等比例修改文件夹下的&#x2F;gui&#x2F;文件夹内的图片进行修改\n本软件基于第四届ASG赛事赛制即第五人格深远的呼唤VI赛制，BO5环境制作，2023 IVL·夏的半全局BP将会于另一个项目进行维护（先挖个坑）\n本软件已于Github开源，欢迎各民间赛事魔改\nhttps://github.com/PLFJY/idv-bp-asg-e\n下载地址：https://github.com/PLFJY/idv-bp-asg-e/releases，下载最新版本的ZIP压缩包完全解压即可\n本软件灵感来源于皮塞冬大佬使用Python制作的BP展示软件 &#x3D;&#x3D;&gt; 自制第五人格bp界面\n\n软件使用介绍：\n\n这个软件功能比较于目前任何一个民间bp展示软件都要多，大致分为“BP系统”与“比分系统”\n\nBP系统：\n先说最基本的角色展示，每一个可下拉的组合框上方都有一个搜索框，可在搜索框里输入相应角色的拼音首拼（注：26号守卫的首拼为“bb”为了自己使用方便，祭司的首拼为“js1”，教授的首拼为“js2”），在下方组合框显示出正确的角色时按下回车即可将结果上传到前台画面，同时相应组合框下方也会出现相应角色的头像（如果是ban就是黑白头像，如果是pick就是彩色头像）。\n关于pick求生者下方预览图下面的数字键：这个是进入游戏后将选手与使用角色对应使用的，点击相应的数字就会把该角色的图片与相应位置角色的图片进行互换\n\n地图BP画面可在直播间闲置画面的左下角放置，没必要放在角色BP阶段的画面展示\n关于计时器：计时器区域的文本框是输入倒计时时间的，输入好后按“开始”则会从这个数字开始倒数，到0即止，按下“停止”则会隐藏前台的计时器显示（手慢、手残党可以不使用这个功能）\n每一回合结束可按下“重置“按钮重置当前角色选择（不会影响地图的BP以及比分系统的比分情况）\n“ban位数量设定面板”则可以设定当前ban位数量\n\n注：这个软件的所有文本框都需要按下回车键内容才会生效，选手ID有自动填充功能，目前只开发了占位填充（全部选手名称变为Player），API填充还在开发中，命名详细规则之后会写在Github的README.md中\n\n同时BP主前台界面的内容会同步至过场画面的窗口中，配合OBS叠加“name”窗口展示选手ID即可达到官方的展示效果。（彗星真彩控件必须最上，所以ID显示只能新弄个窗口）\n\n\n\n比分系统\n比分系统是这个软件一个独立的分支，如需使用，点击后台界面里的“打开比分面板“按钮即可打开比分系统\n\n\n比分系统分为半自动化和手动控制（一般使用半自动化就行了，手动面板一般是点错了想要复原用的），半自动化控制在对局结束后，点击“换边”按钮前选择当前对局结果，一个回合结束后点击大比分结算就能自动结算当前比分，按下”总清零“可以全部重置\n当然，比分系统也准备了游戏内画面的比分显示，分别由两个窗口展示，方便OBS的捕获\n“游戏内比分求生者”窗口放在求生者方的位置，“游戏内比分监管者”窗口放在监管者方的位置（即左上角和右上角，当然你想放哪里其实都可以），游戏内画面显示窗口会同步队伍名称、队伍LOGO、当前比分。\n注：后台还会显示总小比分，方便最后判断队伍胜利情况\n\n\n\n使用须知\n如您想要分享&#x2F;修改本软件，请务必将修改过后的版本进行开源\n队伍LOGO必须为PNG格式，否则会出现显示错误（彗星真彩控件的锅）\n如果下载后发现软件不见了，请检查杀毒软件的保护历史记录，并将该软件加入信任区（易语言老是被搞，习惯了都）\n运行需求\n使用Windows 10 1903以上的系统运行（以下的系统我不保证可以正常运行），使用前请完全解压压缩包，并安装目录下的两个字体文件以达到最佳的使用效果\n使用要求\n请使用原生OBS对于本软件的前台界面进行展示\n请使用OBS内的“窗口采集”且选择采集方式为”“BitBlt”，窗口匹配优先级为“窗口标题必须匹配”并取消勾选“显示鼠标指针”\n对于源使用滤镜添加“色值”，关键颜色为“绿色”，相似度调整为刚刚好看不到绿色即可（多了会把要展示的也扣没了）\n","categories":["第五人格","bp软件"],"tags":["第五人格","bp软件","易语言"]}]